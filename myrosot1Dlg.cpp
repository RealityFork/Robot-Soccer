// myrosot1Dlg.cpp : implementation file
//
#include "stdafx.h"
#include "myrosot1Dlg.h"
#include "AdjColDlg.h"
#include "AdjGameArea.h"
#include "GrabberSettingsDlg.h"
#include "TuningDlg.h"
#include "RFCommDlg.h"
#include "Parameters.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define INTTYPE IRQ_VIDEO

void gameHandler();	//-- function prototype
					//-- this function is called each time the IRQ
					//-- is generated by the FlashBus Vision Card

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMyrosot1Dlg dialog

CMyrosot1Dlg::CMyrosot1Dlg(CWnd* pParent /*=NULL*/)
	: CDialog(CMyrosot1Dlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CMyrosot1Dlg)
	m_SetBoundary = -1;
	m_Red = 0;
	m_Green = 0;
	m_Blue = 0;
	m_Selection = -1;
	m_GameArea = -1;
	m_Bkcolour = FALSE;
	m_Goalieangle = _T("");
	m_Robot1angle = _T("");
	m_Robot2angle = _T("");
	m_FrameCount = 0;
	m_BallFull = 0;
	m_TeamFull = 0;
	m_FullScan = 0;
	m_Diagnostics = -1;
	m_ColourNRange = -1;
	m_Observer = _T("");
	m_DisplayUnit = -1;
	m_FullTrackingOnly = FALSE;
	m_startPhase = -1;
	m_whosePossession = -1;
	m_whichQuadrant = -1;
	m_DisplayHome = -1;
	m_Ball = 0;
	m_Team = 0;
	m_colTuning = FALSE;
	m_Goaliex = _T("");
	m_Goaliey = _T("");
	m_Robot1x = _T("");
	m_Robot1y = _T("");
	m_Robot2x = _T("");
	m_Robot2y = _T("");
	m_Ballx = _T("");
	m_Bally = _T("");
	m_DisplayBoundaries = FALSE;
	m_Time = _T("");
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CMyrosot1Dlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMyrosot1Dlg)
	DDX_Radio(pDX, IDC_FIELDAREA_RADIO, m_SetBoundary);
	DDX_Text(pDX, IDC_R_EDIT, m_Red);
	DDX_Text(pDX, IDC_G_EDIT, m_Green);
	DDX_Text(pDX, IDC_B_EDIT, m_Blue);
	DDX_Radio(pDX, IDC_MAPCOLOURS_RADIO, m_Selection);
	DDX_Radio(pDX, IDC_LEFT_RADIO, m_GameArea);
	DDX_Check(pDX, IDC_BLACKBACKGROUND_CHECK, m_Bkcolour);
	DDX_Text(pDX, IDC_GOALIEANGLE_EDIT, m_Goalieangle);
	DDX_Text(pDX, IDC_ROBOT1ANGLE_EDIT, m_Robot1angle);
	DDX_Text(pDX, IDC_ROBOT2ANGLE_EDIT, m_Robot2angle);
	DDX_Text(pDX, IDC_FRAMECOUNT_EDIT, m_FrameCount);
	DDX_Text(pDX, IDC_BALLFULL_EDIT, m_BallFull);
	DDX_Text(pDX, IDC_TEAMFULL_EDIT, m_TeamFull);
	DDX_Text(pDX, IDC_FULLSCAN_EDIT, m_FullScan);
	DDX_Radio(pDX, IDC_OFF_RADIO, m_Diagnostics);
	DDX_Radio(pDX, IDC_BALL_RADIO, m_ColourNRange);
	DDX_Text(pDX, IDC_OBSERVER_EDIT, m_Observer);
	DDX_Radio(pDX, IDC_DISPLAY_CM_RADIO, m_DisplayUnit);
	DDX_Check(pDX, IDC_FULLTRACKINGONLY_CHECK, m_FullTrackingOnly);
	DDX_Radio(pDX, IDC_KICKSTART_RADIO, m_startPhase);
	DDX_Radio(pDX, IDC_HOME_RADIO, m_whosePossession);
	DDX_Radio(pDX, IDC_TOPLEFT_RADIO, m_whichQuadrant);
	DDX_Radio(pDX, IDC_DISPLAY_HOME_RADIO, m_DisplayHome);
	DDX_Text(pDX, IDC_BALL_EDIT, m_Ball);
	DDX_Text(pDX, IDC_TEAM_EDIT, m_Team);
	DDX_Check(pDX, IDC_COLORTUNING_CHECK, m_colTuning);
	DDX_Text(pDX, IDC_GOALIEX_EDIT, m_Goaliex);
	DDX_Text(pDX, IDC_GOALIEY_EDIT, m_Goaliey);
	DDX_Text(pDX, IDC_ROBOT1X_EDIT, m_Robot1x);
	DDX_Text(pDX, IDC_ROBOT1Y_EDIT, m_Robot1y);
	DDX_Text(pDX, IDC_ROBOT2X_EDIT, m_Robot2x);
	DDX_Text(pDX, IDC_ROBOT2Y_EDIT, m_Robot2y);
	DDX_Text(pDX, IDC_BALLX_EDIT, m_Ballx);
	DDX_Text(pDX, IDC_BALLY_EDIT, m_Bally);
	DDX_Check(pDX, IDC_DISPLAYBOUNDARIES_CHECK, m_DisplayBoundaries);
	DDX_Text(pDX, IDC_TIME_EDIT, m_Time);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CMyrosot1Dlg, CDialog)
	//{{AFX_MSG_MAP(CMyrosot1Dlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_COMMAND(ID_FILE_EXIT, OnFileExit)
	ON_COMMAND(ID_HELP_ABOUT, OnHelpAbout)
	ON_WM_SIZE()
	ON_WM_LBUTTONUP()
	ON_WM_LBUTTONDOWN()
	ON_WM_MOUSEMOVE()
	ON_BN_CLICKED(IDC_LEFT_RADIO, OnLeftRadio)
	ON_BN_CLICKED(IDC_RIGHT_RADIO, OnRightRadio)
	ON_BN_CLICKED(IDC_OFF_RADIO, OnOffRadio)
	ON_BN_CLICKED(IDC_HIGH_RADIO, OnHighRadio)
	ON_BN_CLICKED(IDC_LOW_RADIO, OnLowRadio)
	ON_BN_CLICKED(IDC_START_BUTTON, OnStartButton)
	ON_BN_CLICKED(IDC_STOP_BUTTON, OnStopButton)
	ON_BN_CLICKED(IDC_TEST_BUTTON, OnTestButton)
	ON_WM_TIMER()
	ON_BN_CLICKED(IDC_STOPTEST_BUTTON, OnStoptestButton)
	ON_BN_CLICKED(IDC_BLACKBACKGROUND_CHECK, OnBlackbackgroundCheck)
	ON_BN_CLICKED(IDC_GETREADY_BUTTON, OnGetreadyButton)
	ON_BN_CLICKED(IDC_SAVECOLORS_BUTTON, OnSavecolorsButton)
	ON_BN_CLICKED(IDC_LOADCOLOURS_BUTTON, OnLoadcoloursButton)
	ON_WM_RBUTTONDBLCLK()
	ON_BN_CLICKED(IDC_ADJUSTRANGE_BUTTON, OnAdjustrangeButton)
	ON_BN_CLICKED(IDC_UPDATELUT_BUTTON, OnUpdatelutButton)
	ON_COMMAND(ID_UTILS_RFCOMM, OnUtilsRfcomm)
	ON_BN_CLICKED(IDC_MAPCOLOURS_RADIO, OnMapcoloursRadio)
	ON_BN_CLICKED(IDC_SETBOUNDARIES_RADIO, OnSetboundariesRadio)
	ON_BN_CLICKED(IDC_FIELDAREA_RADIO, OnFieldareaRadio)
	ON_BN_CLICKED(IDC_HOMEGOALAREA_RADIO, OnHomegoalareaRadio)
	ON_BN_CLICKED(IDC_OPPOGOALAREA_RADIO, OnOppogoalareaRadio)
	ON_WM_RBUTTONDOWN()
	ON_WM_LBUTTONDBLCLK()
	ON_COMMAND(ID_UTILS_SETPARAMETERS, OnUtilsSetparameters)
	ON_COMMAND(ID_UTILS_ADJUSTGAMEAREA, OnUtilsAdjustgamearea)
	ON_BN_CLICKED(IDC_DISPLAY_CM_RADIO, OnDisplayCmRadio)
	ON_BN_CLICKED(IDC_DISPLAY_PIXEL_RADIO, OnDisplayPixelRadio)
	ON_BN_CLICKED(IDC_FULLTRACKINGONLY_CHECK, OnFulltrackingonlyCheck)
	ON_COMMAND(ID_GRABBER_SETTINGS, OnGrabberSettings)
	ON_BN_CLICKED(IDC_KICKSTART_RADIO, OnKickstartRadio)
	ON_BN_CLICKED(IDC_GOALKICK_RADIO, OnGoalkickRadio)
	ON_BN_CLICKED(IDC_PENALTY_RADIO, OnPenaltyRadio)
	ON_BN_CLICKED(IDC_FREEKICK_RADIO, OnFreekickRadio)
	ON_BN_CLICKED(IDC_FREEBALL_RADIO, OnFreeballRadio)
	ON_BN_CLICKED(IDC_HOME_RADIO, OnHomeRadio)
	ON_BN_CLICKED(IDC_OPPONENT_RADIO, OnOpponentRadio)
	ON_BN_CLICKED(IDC_TOPLEFT_RADIO, OnTopleftRadio)
	ON_BN_CLICKED(IDC_TOPRIGHT_RADIO, OnToprightRadio)
	ON_BN_CLICKED(IDC_BOTTOMLEFT_RADIO, OnBottomleftRadio)
	ON_BN_CLICKED(IDC_BOTTOMRIGHT_RADIO, OnBottomrightRadio)
	ON_BN_CLICKED(IDC_GO_BUTTON, OnGoButton)
	ON_COMMAND(ID_UTILS_TUNING, OnUtilsTuning)
	ON_BN_CLICKED(IDC_DISPLAY_HOME_RADIO, OnDisplayHomeRadio)
	ON_BN_CLICKED(IDC_DISPLAY_OPPO_RADIO, OnDisplayOppoRadio)
	ON_COMMAND(ID_UTILS_TESTING, OnUtilsTesting)
	ON_BN_CLICKED(IDC_COLORTUNING_CHECK, OnColortuningCheck)
	ON_BN_CLICKED(IDC_QSTATE_BUTTON, OnQstateButton)
	ON_BN_CLICKED(IDC_DISPLAYBOUNDARIES_CHECK, OnDisplayboundariesCheck)
	ON_BN_CLICKED(IDC_BALL_RADIO, OnBallRadio)
	ON_BN_CLICKED(IDC_ROBOT1_RADIO, OnRobot1Radio)
	ON_BN_CLICKED(IDC_ROBOT2_RADIO, OnRobot2Radio)
	ON_BN_CLICKED(IDC_TEAM_RADIO, OnTeamRadio)
	ON_BN_CLICKED(IDC_OPPO_RADIO, OnOppoRadio)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


//-- create the global variable to hold all common data
commondata globaldata;
BYTE LUT[256*256*256L] = {0};	//-- Create Look Up Table
int gMinPatchSizeTeam;	//-- minimum patch size for team colour
int gMinPatchSizeCol1;	//-- minimum patch size for colour1
int gMinPatchSizeCol2;	//-- minimum patch size for colour2
int gMinPatchSizeOppo;	//-- minimum patch size for Oppo colour
int gMinPatchSizeBall;	//-- minimum patch size for Ball colour

int gNumRobots;			//-- number of robots in play
int gNumOppoRobots;		//-- number of opponent robots in play
//-- count of how many times a particular robot is not found
not_found_count gNotFoundCount;
removed_robots gRemoved;	//-- robots removed from play
grabber_settings FBus;	//-- Vision card settings
LPBYTE pCapData;	//-- pointer to the memory used to
					//-- copy the capture window
LPBYTE pZoomWin;	//-- pointer to the memory used to
					//-- store the zoom window
LPBYTE pSearchWin[MAXROBOTS];//-- pointer to the memory used to copy the
							 //-- search window for locating robot color
LPBYTE pTrackWinTeam[MAXROBOTS];//-- pointers to the memory used to copy the
								//-- tracking window for locating team color
LPBYTE pTrackWinBall;	//-- pointer to the memory used to copy the
						//-- tracking window for locating ball color
LPBYTE pTrackWinOppo[MAXROBOTS];	//-- pointers to the memory used to copy the
								//-- tracking window for locating opponent color

BOOL gParallaxCorrectionEnabled;	//-- Parallax correction variable
BOOL gStopRobotsWhenBallLost;	//-- Stop Robots when ball not found
BOOL gGoalieFollowClick;		//-- goalie to follow the clicked point
								//-- when opponent takes penalty
float gVelocityScaling;	//-- velocity scaling factor
float gSpinVelocityScaling;
StartPosition gStartingPosition;	//-- starting positions
float gCameraHeight;
BOOL gTrackOpponent;	//-- track the opponent position?

//-- for tuning ---------------------------------------------------------
GoalieActionparameters gGoalieActionParameters;	//-- for CGoalieAction
//-- for tuning ---------------------------------------------------------

BOOL gfoundBall;
BOOL gfoundR1, gfoundR2, gfoundGoalie;
BOOL VideoLive;

int gChoice;		//-- choice of testing

//-- incremental window size for colour patches -----
POINT inctopTeam[MAXROBOTS];
POINT incbottomTeam[MAXROBOTS];

POINT inctopBall;
POINT incbottomBall;

POINT inctopOppo[MAXROBOTS];
POINT incbottomOppo[MAXROBOTS];

LPBYTE lpImageBuf;
WORD wIRQNum;
BYTE HUGE *lpDib[4];
HANDLE hDib[4];
CAPMEMINFO CapMemInfo;	//-- Capture Memory Information
BYTE fieldType[4];
int nCount;
int timerCount;
float gBallClearTime;	//-- time after which goalie
						//-- will clear the ball (in Seconds)
int halfFrameJump;

startPhaseVal gstartPhaseVal[5];

BOOL FBUSINSTALLED;	//-- is the Vision Card installed?

/////////////////////////////////////////////////////////////////////////////
// CMyrosot1Dlg message handlers

BOOL CMyrosot1Dlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	// TODO: Add extra initialization here

	//---- [START] Initialise variables ------------------------------
//	FBUSINSTALLED = FALSE;	//-- Vision card is NOT installed
	FBUSINSTALLED = TRUE;	//-- Vision card is installed

	showZoomWindow = FALSE; //-- Initially do not show the zoom window
	capPoint = CPoint(0,0);	//-- point clicked within the Capture Window

	pZoomWin = (LPBYTE) malloc( (CAPSIZE+1)*2 * (CAPSIZE+1)*2 * 3);
	if (pZoomWin == NULL)
		MessageBox("Cannot allocate enough memory for Zoom Window Picture",
						"ERROR", MB_OK+MB_ICONSTOP);

	Prev = Current = CPoint(0,0);
	RGBColourBox = 0;

	gMinPatchSizeTeam = MINPATCHSIZETEAM;	//-- minimum patch size for team colour
	gMinPatchSizeCol1 = MINPATCHSIZECOL1;	//-- minimum patch size for colour1
	gMinPatchSizeCol2 = MINPATCHSIZECOL2;	//-- minimum patch size for colour2
	gMinPatchSizeOppo = MINPATCHSIZEOPPO;	//-- minimum patch size for Oppo colour
	gMinPatchSizeBall = MINPATCHSIZEBALL;	//-- minimum patch size for Ball colour

	gParallaxCorrectionEnabled = TRUE;	//-- Parallax correction enabled
	gStopRobotsWhenBallLost = FALSE;	//-- do not stop the robots when ball not found
	gGoalieFollowClick = TRUE;		//-- goalie should follow the clicked point
									//-- when opponent takes penalty
	gVelocityScaling = (float)VELOCITYSCALING;	//-- velocity scaling factor
	gSpinVelocityScaling = (float)SPINVELOCITYSCALING;	//-- spin velocity scaling

	halfFrameJump=1;

	gCameraHeight = (float)200;

	//-- count of number of times a particular robot is not found
	gNotFoundCount.Goalie = gNotFoundCount.Robot1 = gNotFoundCount.Robot2 = 0;

	gNumRobots = MAXROBOTS;	//-- initially 3 robots in play
	gNumOppoRobots = MAXROBOTS;	//-- initially 3 opponent robots in play
	gTrackOpponent = FALSE;	//-- do not track the opponent

	//-- none of the robots removed from play initially ------
	gRemoved.Goalie = gRemoved.Robot1 = gRemoved.Robot2 = FALSE;
	gNumRobots = 3;

	//gChoice = 0;	//-- Striker chase the ball
	//gChoice = 1;	//-- Position Goalie at 90 degrees - Testing Angle() function
	//gChoice = 2;	//-- TO POSITION STRIKER AT THE POINT CLICKED IN THE CAPTURE WINDOW
					//-- Testing Position() function
	//gChoice = 3;
	//gChoice = 4;
	//gChoice = 5;
	//gChoice = 6;
	//gChoice = 7;	//-- State Based GOALIE
	//gChoice = 8;
	//gChoice = 9;
	//gChoice = 10;	//-- State Based kick start & NORMAL Game
	//gChoice = 11;
	//gChoice = 12;

	gChoice = 10;	//-- Normal game

	gBallClearTime = (float)0.1;	//-- goalie will clear the ball in 0.1 sec

	m_ParametersDlg->m_GoalieRemoved = gRemoved.Goalie;
	m_ParametersDlg->m_Robot1Removed = gRemoved.Robot1;
	m_ParametersDlg->m_Robot2Removed = gRemoved.Robot2;

	//-- make pdata point to the global variable which stores all common data
	pdata = &globaldata;
	pdata->pmainwindow = this;	//-- pointer to the main dialog window

	pdata->timer1_installed = FALSE;	//-- initially timer is not installed
	pdata->timer2_installed = FALSE;	//-- initially timer is not installed
	pdata->lefttop = CPoint(0, 0);
	pdata->rightbottom = CPoint(MaxX, MaxY);
	pdata->homegoaltop = CPoint(0,0);
	pdata->homegoalbottom = CPoint(0,0);
	pdata->oppgoaltop = CPoint(0,0);
	pdata->oppgoalbottom = CPoint(0,0);

	pdata->start = FALSE;
	pdata->FullTrackingOnly = m_FullTrackingOnly = FALSE;

	pdata->ballcol = 0;
	pdata->ballcolR = 0;pdata->ballcolG = 0;pdata->ballcolB = 0;
	pdata->robot1col = 0;
	pdata->robot1colR = 0;pdata->robot1colG = 0;pdata->robot1colB = 0;
	pdata->robot2col = 0;
	pdata->robot2colR = 0;pdata->robot2colG = 0;pdata->robot2colB = 0;
	pdata->teamcol = 0;
	pdata->teamcolR = 0;pdata->teamcolG = 0;pdata->teamcolB = 0;
	pdata->oppocol = 0;
	pdata->oppocolR = 0;pdata->oppocolG = 0;pdata->oppocolB = 0;

	pdata->ballcolYmin=0; pdata->ballcolYmax=0;
	pdata->ballcolUmin=0; pdata->ballcolUmax=0;
	pdata->ballcolVmin=0; pdata->ballcolVmax=0;

	pdata->robot1colYmin=0; pdata->robot1colYmax=0;
	pdata->robot1colUmin=0; pdata->robot1colUmax=0;
	pdata->robot1colVmin=0; pdata->robot1colVmax=0;

	pdata->robot2colYmin=0; pdata->robot2colYmax=0;
	pdata->robot2colUmin=0; pdata->robot2colUmax=0;
	pdata->robot2colVmin=0; pdata->robot2colVmax=0;

	pdata->teamcolYmin=0; pdata->teamcolYmax=0;
	pdata->teamcolUmin=0; pdata->teamcolUmax=0;
	pdata->teamcolVmin=0; pdata->teamcolVmax=0;

	pdata->oppocolYmin=0; pdata->oppocolYmax=0;
	pdata->oppocolUmin=0; pdata->oppocolUmax=0;
	pdata->oppocolVmin=0; pdata->oppocolVmax=0;

	pdata->ballpos.x=0;	pdata->ballpos.y=0;
	pdata->goaliepos.x=0;pdata->goaliepos.y=0;
	pdata->robot1pos.x=0;pdata->robot1pos.y=0;
	pdata->robot2pos.x=0;pdata->robot2pos.y=0;

	pdata->teamcolpos1.x=0;	pdata->teamcolpos1.y=0;
	pdata->teamcolpos2.x=0;	pdata->teamcolpos2.y=0;
	pdata->teamcolpos3.x=0;	pdata->teamcolpos3.y=0;

	pdata->oppocolpos1.x=0;	pdata->oppocolpos1.y=0;
	pdata->oppocolpos2.x=0;	pdata->oppocolpos2.y=0;
	pdata->oppocolpos3.x=0;	pdata->oppocolpos3.y=0;

	pdata->oldballpos.x=0;pdata->oldballpos.y=0;
	pdata->oldgoaliepos.x=0;pdata->oldgoaliepos.y=0;
	pdata->oldrobot1pos.x=0;pdata->oldrobot1pos.y=0;
	pdata->oldrobot2pos.x=0;pdata->oldrobot2pos.y=0;

	pdata->ballvel.x=0;pdata->ballvel.y=0;
	pdata->goalievel.x=0;pdata->goalievel.y=0;
	pdata->robot1vel.x=0;pdata->robot1vel.y=0;
	pdata->robot2vel.x=0;pdata->robot2vel.y=0;

	pdata->goalieangle=0;
	pdata->robot1angle=0;
	pdata->robot2angle=0;

	pdata->FullScan = m_FullScan = 0;
	pdata->Team = m_Team = 0;
	pdata->TeamFull = m_TeamFull = 0;
	pdata->Ball = m_Ball = 0;
	pdata->BallFull = m_BallFull = 0;
	pdata->FrameCount = m_FrameCount = 0;

	m_Selection = 0;	//-- Initially Map Colours radio button selected
	m_SetBoundary = 0;	//-- Initially select Field Area
	pdata->SetBoundary = 0;
	m_DisplayUnit = 0;	//-- Initially Coordinates Displayed in Cm
	m_DisplayHome = 0;	//-- Initially Coodinates Displayed for Home robots
	pdata->Bkcolour = m_Bkcolour = FALSE;	//-- Black background colour is turned off
	pdata->DisplayBoundaries = m_DisplayBoundaries = TRUE;	//-- show boundaries

	m_Red = 0;
	m_Green = 0;
	m_Blue = 0;

	m_GameArea = pdata->game_area = LEFT_AREA;	//-- initially game area is LEFT
	m_Diagnostics = pdata->diagnostics = LOW;	//-- diagnostics OFF

	//-- which colour to test?
	m_ColourNRange = 0;	//-- select Ball
	refcol = (BYTE) BALLCOL;

	//-- initialisation of placement status ---------------------
	m_startPhase = gStartingPosition.StartPhase = KICKSTART;
	m_whosePossession = gStartingPosition.whosePossession = HOME;
	m_whichQuadrant = gStartingPosition.whichQuadrant = TOPLEFT;
	//-----------------------------------------------------------

	//----- Tuning ----------------------------------------------

	gGoalieActionParameters.GBehaviour = 0;	//-- 0 : Conservative behaviour
												//-- 1 : Normal behaviour
												//-- 2 : Aggressive behaviour
	gGoalieActionParameters.GXcompensation = 1.0;	//-- 1.0 cm inside the goalie's intended X-Position
	//-----------------------------------------------------------

	gfoundBall = FALSE;	//-- ball found is initially false
	gfoundR1 = gfoundR2 = gfoundGoalie = FALSE;	//-- none of the robots found

	//-- Initialise the action states
	pdata->GState = 0;
	pdata->R1State = 0;
	pdata->R2State = 0;

	//---- PositionState initialisation
	pdata->PositionState = 2;		//-- Idle state is 2

	//-- Tuning mode on or not (controls stretch build display)
	m_colTuning = pdata->colTuning = TRUE;//-- initially set for colour tuning
	pdata->fullFrame = TRUE;	//-- process full frame

	UpdateData(FALSE);//-- transfer control variables to screen

	//-- initialisation for strategy ---------
	pdata->ballposS.x = 0;	 pdata->ballposS.y = 0;
	pdata->goalieposS.x = 0; pdata->goalieposS.y = 0;
	pdata->robot1posS.x = 0; pdata->robot1posS.y = 0;
	pdata->robot2posS.x = 0; pdata->robot2posS.y = 0;
	
	pdata->oldballposS.x = 0; pdata->oldballposS.y = 0;
	pdata->oldgoalieposS.x = 0; pdata->oldgoalieposS.y = 0;
	pdata->oldrobot1posS.x = 0; pdata->oldrobot1posS.y = 0;
	pdata->oldrobot2posS.x = 0; pdata->oldrobot2posS.y = 0;

	pdata->ballvelS.x = 0; pdata->ballvelS.y = 0;
	pdata->goalievelS.x = 0; pdata->goalievelS.y = 0;
	pdata->robot1velS.x = 0; pdata->robot1velS.y = 0;
	pdata->robot2velS.x = 0; pdata->robot2velS.y = 0;

	pdata->goalieangleS = 0;
	pdata->robot1angleS = 0;
	pdata->robot2angleS = 0;

	pdata->LUTupdated = FALSE;

	pdata->capPoint = CPoint(160,120);	//-- middle of the field

	pdata->comport = COM1;	//-- default port for Communication
	openSerialPort();	//-- open & initialise Comunication Port
	initPacket();	//-- initialise communication packet with HEADER,
					//-- ROBOTIDs and 0 velocities for each robot

	gstartPhaseVal[GOALKICK].kickdistance = 75;
	gstartPhaseVal[GOALKICK].kickspeed = 100;

	gstartPhaseVal[PENALTY].kickdistance = 30;
	gstartPhaseVal[PENALTY].kickspeed = 113;

	gstartPhaseVal[FREEKICK].kickdistance = 40;
	gstartPhaseVal[FREEKICK].kickspeed = 113;

	gstartPhaseVal[FREEBALL].kickdistance = 5;
	gstartPhaseVal[FREEBALL].kickspeed = 80;

	gstartPhaseVal[KICKSTART].kickdistance = 8;
	gstartPhaseVal[KICKSTART].kickspeed = 8;

	//---- [END] Initialise variables ------------------------------

	//-- Monitor resolution is 800x600 ----------------
	SetWindowPos(NULL, 0, 0, ScreenX, ScreenY, SWP_SHOWWINDOW);

	//---- Set default video levels ---------------
	FBus.brightness = 34;
	FBus.contrast = 35;
	FBus.saturation = 32;
	FBus.hue = 0;
	FBus.sharpness = 7;

	//-------  Define Video Standard and Type -------
	FBus.wStandard	= STANDARD_NTSC;
	FBus.wVideoType = TYPE_COMPOSITE;
	FBus.CameraOnOff = TRUE;	//-- initially camera is ON

	if (FBUSINSTALLED)
	{
		FB_Init();
	//	To use channel 0
		FB_SetVideoConfig(FBus.wVideoType, FBus.wStandard, 0, FALSE);

	//	For FlasBus MV Lite, the channel is 1
	//	FB_SetVideoConfig(FBus.wVideoType, FBus.wStandard, 1, FALSE);

		Delay(30);

		//-- get the Vision Card settings
		char szarVal[MAXSTRING];
		char szarDef[MAXSTRING];

		//-- Get Default video levels from FBG.INI if we have one
		wsprintf(szarDef,"%d", FBus.brightness);
		FB_GetPrivateProfileString("VideoInput", "Brightness", szarDef, szarVal, MAXSTRING, INIFile);
		FBus.brightness=atoi(szarVal);

		wsprintf(szarDef,"%d", FBus.contrast);
		FB_GetPrivateProfileString("VideoInput", "Contrast", szarDef, szarVal, MAXSTRING, INIFile);
		FBus.contrast=atoi(szarVal);

		wsprintf(szarDef,"%d", FBus.saturation);
		FB_GetPrivateProfileString("VideoInput", "Saturation", szarDef, szarVal, MAXSTRING, INIFile);
		FBus.saturation=atoi(szarVal);

		wsprintf(szarDef,"%d", FBus.hue);
		FB_GetPrivateProfileString("VideoInput", "Hue", szarDef, szarVal, MAXSTRING, INIFile);
		FBus.hue=atoi(szarVal);

		wsprintf(szarDef,"%d", FBus.sharpness);
		FB_GetPrivateProfileString("VideoInput", "Sharpness", szarDef, szarVal, MAXSTRING, INIFile);
		FBus.sharpness=atoi(szarVal);

		//-- Do the Video Adjustments -----------
		FB_SetVideoAdjustments(ADJUST_BRIGHTNESS, (SHORT)FBus.brightness);
		FB_SetVideoAdjustments(ADJUST_CONTRAST, (SHORT)FBus.contrast);
		FB_SetVideoAdjustments(ADJUST_SATURATION, (SHORT)FBus.saturation);
		FB_SetVideoAdjustments(ADJUST_HUE, (SHORT)FBus.hue);
		FB_SetVideoAdjustments(ADJUST_SHARPNESS, (SHORT)FBus.sharpness);
	}
	
	pdata->coloursLoaded = FALSE;
	OnLoadcoloursButton();	//-- load colours & Update LUT on startup

	//-- allocate memory for off-screen capture --------
	HANDLE hImageBuf;
	hImageBuf = GlobalAlloc(GMEM_MOVEABLE, 0x200000);
	lpImageBuf = (LPBYTE)GlobalLock(hImageBuf);
	if (lpImageBuf == NULL)
	{
		MessageBox("Could not allocate image buffer", "GlobalAlloc Error", MB_ICONSTOP);
		return 0;
	}

	//-- allocate 4 DIB buffers -------------
	int i;
	for (i=0; i<4; i++)
	{
		hDib[i] = GlobalAlloc(GMEM_MOVEABLE,
			( (DWORD)NTSCVIDEOWIDTH*NTSCVIDEOHEIGHT*3L)+sizeof(BITMAPINFOHEADER) + 1024L);
		lpDib[i] = (BYTE HUGE *)GlobalLock(hDib[i]);
	}
	CapMemInfo.dwMemPtr = (DWORD)lpImageBuf;
	CapMemInfo.dwMemSize = 0x200000;
	//-- lock the user-allocated buffer to use for off-screen capture
	if (FBUSINSTALLED)
	{
		FB_VideoCaptureMem(&CapMemInfo, VCM_SETMEMBUFFER);

		//-- set the video capture to off-screen system memory at 24 bpp ------
		if ( FB_VideoOffscreen(CapSizeX, CapSizeY, 24, TRUE) )
		{
			MessageBox("FB_VideoOffscreen() failed", "Error", MB_ICONSTOP);
			return 0;
		}

		pdata->IRQEnabled = false;	//-- IRQ not yet enabled

		//-- get the IRQ number for FB -------
		wIRQNum = FB_GetIRQNumber();

		//-- start incoming video and
		//-- align the frame as odd field, then even field -----
		FB_VideoLive(TRUE, ALIGN_ODD);
		FB_WaitFieldType(ALIGN_EVEN);//-- Wait for even fields to start
		FB_WaitMS(8);//-- Delay half of even frame
		//-- enable the interrupt handler -----
		//-- when the first interrupt comes on the next VSYNC
		//-- it is expected to be ODD field

		if (!pdata->IRQEnabled)
		{
			FB_EnableIRQ(INTTYPE, wIRQNum, true, gameHandler);
			pdata->IRQEnabled = true;
		}
	}
	nCount=-1;//-- so first frame is not processed initially

	// Behaviour instances
	pdata->gBehaviour  = new CGoalieAction  (HGOALIE, 0);
	pdata->r1Behaviour = new CDefenderAction(HROBOT1, 0);
	pdata->r2Behaviour = new CStrikerAction (HROBOT2, 0);
	

	return TRUE;
}

void CMyrosot1Dlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

void CMyrosot1Dlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CClientDC dc(this);

		if (showZoomWindow)	//-- show the zoom window
		{
			int  pixelValue;
			BYTE red, green, blue;
			LPBYTE pZoomWinVar;

			pZoomWinVar = pZoomWin;	//-- make a copy of pZoomWin
									//-- pZoomWin must not be changed !!
			short i, j;
			short p, q;
			for(j=0; j<CAPSIZE*2; j++)
			{
				for(i=0; i<CAPSIZE*2; i++)
				{
					blue = *pZoomWinVar++;
					green = *pZoomWinVar++;
					red = *pZoomWinVar++;

					pixelValue = blue + (green<<8)+(red<<16);
					for (p=i*10; p<i*10+10; p++)
						for(q=j*10; q<j*10+10; q++)
							dc.SetPixel(ZoomWinX+p, ZoomWinY+q-VideoOriginY, RGB(red, green, blue) );
				}
			}

		}	//-- if (showZoomWindow) ---

		//-- display the colour boxes ------------------------
		if (RGBColourBox != 0)
			dc.FillSolidRect(720, 210, 20, 20, RGBColourBox);
		if (pdata->ballcol != 0)
			dc.FillSolidRect(640, 307, 15, 15, pdata->ballcol);
		if (pdata->robot1col != 0)
			dc.FillSolidRect(640, 330, 15, 15, pdata->robot1col);
		if (pdata->robot2col != 0)
			dc.FillSolidRect(640, 353, 15, 15, pdata->robot2col);
		if (pdata->teamcol != 0)
			dc.FillSolidRect(640, 376, 15, 15, pdata->teamcol);
		if (pdata->oppocol != 0)
			dc.FillSolidRect(640, 399, 15, 15, pdata->oppocol);

		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CMyrosot1Dlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

void CMyrosot1Dlg::OnFileExit() 
{
	//-- save colours if user wants it
	int nResponse;
	nResponse = MessageBox("Do you want to save colours?", "Exit",
							MB_ICONQUESTION|MB_YESNOCANCEL|MB_DEFBUTTON2);

	if (nResponse == IDCANCEL)	//-- if CANCEL button pressed, return
		return;

	if (nResponse == IDYES)	//-- if YES button pressed
		OnSavecolorsButton();

	OnStopButton();	//-- as if stop button pressed. All robots stop
					//-- ALSO, continuous streaming (Live Video) is enabled

	closeSerialPort(); //-- close the communication port

	if (pdata->timer1_installed)
	{
		pdata->timer1_installed = FALSE;
		KillTimer(1);
	}

	if (pdata->timer2_installed)
	{
		pdata->timer2_installed = FALSE;
		KillTimer(2);
	}
	//-- Disable interrupt
	if (pdata->IRQEnabled)
	{
		FB_EnableIRQ(INTTYPE, wIRQNum, false, gameHandler);
		pdata->IRQEnabled = false;
	}

	//--  release memory
	if (lpImageBuf)
	{
	  CapMemInfo.dwMemPtr=(DWORD)lpImageBuf;
	  CapMemInfo.dwMemSize=0x200000;
	  if (FBUSINSTALLED) FB_VideoCaptureMem(&CapMemInfo, VCM_RELEASEMEMBUFFER);
	}

	if (FBUSINSTALLED)
	{
		//-- cleanup the Flash Bus grabber card
		FB_Cleanup();

		//-- save the vision card settings in the INI file
		char szarVal[MAXSTRING];

		wsprintf(szarVal, "%d", FBus.brightness);
		FB_WritePrivateProfileString("VideoInput", "Brightness", szarVal,
			  INIFile);

		wsprintf(szarVal, "%d", FBus.contrast);
		FB_WritePrivateProfileString("VideoInput", "Contrast", szarVal,
			 INIFile);

		wsprintf(szarVal, "%d", FBus.saturation);
		FB_WritePrivateProfileString("VideoInput", "Saturation", szarVal,
			 INIFile);
     
		wsprintf(szarVal, "%d", FBus.hue);
		FB_WritePrivateProfileString("VideoInput", "Hue", szarVal,
			 INIFile);

		wsprintf(szarVal, "%d", FBus.sharpness);
		FB_WritePrivateProfileString("VideoInput", "Sharpness", szarVal,
			  INIFile);

		wsprintf(szarVal, "%d", CapSizeX);
		FB_WritePrivateProfileString("Window", "WinWidth", szarVal,
			 INIFile);
		wsprintf(szarVal, "%d", CapSizeY);
		FB_WritePrivateProfileString("Window", "WinHeight", szarVal,
			 INIFile);
	}

	MessageBeep((WORD)-1);
	OnOK();
}

void CMyrosot1Dlg::OnUtilsRfcomm() 
{
	m_RFCommDlg->DoModal();
}

void CMyrosot1Dlg::OnUtilsSetparameters() 
{
	m_ParametersDlg->DoModal();	
}

void CMyrosot1Dlg::OnUtilsTuning() 
{
	m_TuningDlg->DoModal();
}

void CMyrosot1Dlg::OnUtilsTesting() 
{
	CTestingDlg temp;
	temp.DoModal();

	m_ParametersDlg->m_GoalieRemoved = gRemoved.Goalie;
	m_ParametersDlg->m_Robot1Removed = gRemoved.Robot1;
	m_ParametersDlg->m_Robot2Removed = gRemoved.Robot2;
}

void CMyrosot1Dlg::OnUtilsAdjustgamearea() 
{
	//-- install a timer
	int iInstallResult;
	iInstallResult = SetTimer(2, 400, NULL); //-- every 400 mSec
	pdata->timer2_installed = TRUE;

	//-- create the Adjust Game Area Dialog Box
	m_AdjGameAreaDlg->DoModal();

	m_SetBoundary = pdata->SetBoundary;
	UpdateData(FALSE);

	//-- kill the timer #2
	KillTimer(2);
	pdata->timer2_installed = FALSE;
}

void CMyrosot1Dlg::OnHelpAbout() 
{
	CAboutDlg dlg;
	dlg.DoModal();
}

void CMyrosot1Dlg::OnSize(UINT nType, int cx, int cy) 
{
	CDialog::OnSize(nType, cx, cy);
	
	// TODO: Add your message handler code here
}

void CMyrosot1Dlg::OnLButtonUp(UINT nFlags, CPoint point) 
{
	UpdateData(TRUE);	//-- transfer screen data to control variables
	//-- If the point clicked is within the capture window
	if (point.x >= 0 && point.x <= MaxX && point.y >= 0 && point.y <= MaxY)
	{
		pdata->capPoint = point;

		if (pdata->start == TRUE)	return;

		if (m_Selection==0) //-- Map Colours Radio button has been chosen
		{
			int  pixelValue;
			BYTE red, green, blue;
			capPoint = point;
			LPBYTE pZoomWinVar;

			if (capPoint.x < CAPSIZE) capPoint.x = CAPSIZE;
			if (capPoint.y < CAPSIZE) capPoint.y = CAPSIZE;
			if (capPoint.x > MaxX-CAPSIZE) capPoint.x = MaxX-CAPSIZE;
			if (capPoint.y > MaxY-CAPSIZE) capPoint.y = MaxY-CAPSIZE;

			pZoomWinVar = lpImageBuf + (nCount*(DWORD)CapSizeX*CapSizeY*3L)+sizeof(BITMAPINFOHEADER)+1024L;
			pZoomWinVar += (CapSizeX*(capPoint.y-CAPSIZE) + capPoint.x-CAPSIZE)*3;

			short i, j;
			short p, q;
			int count = 0;
			for(j=0; j<CAPSIZE*2; j++)
			{
				for(i=0; i<CAPSIZE*2; i++)
				{
					*(pZoomWin + count) = blue = *pZoomWinVar++; count++;
					*(pZoomWin + count) = green = *pZoomWinVar++; count++;
					*(pZoomWin + count) = red = *pZoomWinVar++; count++;

					pixelValue = blue + (green<<8)+(red<<16);
					for (p=i*10; p<i*10+10; p++)
					{
						for(q=j*10; q<j*10+10; q++)
						{
							FB_SetVGAPixel(ZoomWinX+p, ZoomWinY+q, pixelValue);
						}
					}
				}
				pZoomWinVar +=	(CapSizeX - CAPSIZE*2)*3;
			}

			showZoomWindow = TRUE;

		}	//-- end of colour mapping
		
		else  //-- Set Boundaries Radio button has been chosen
		{
			CDC *pDC = GetDC();
			CPen aWhitePen, aBluePen, aRedPen, *pOldPen;

			switch(m_SetBoundary)
			{
				//-- Case 0 ------> set field area
				case 0	:	aWhitePen.CreatePen(PS_SOLID, 1, RGB(255, 255, 255) );
							pOldPen = (CPen *)pDC->SelectObject(&aWhitePen);
					
							pdata->rightbottom = point;

							pDC->MoveTo(pdata->lefttop);
							pDC->LineTo(pdata->rightbottom.x, pdata->lefttop.y);
							pDC->LineTo(pdata->rightbottom);
							pDC->LineTo(pdata->lefttop.x, pdata->rightbottom.y);
							pDC->LineTo(pdata->lefttop);

							aWhitePen.DeleteObject();

							break;

				//-- Case 1 ------> set homegoal area
				case 1	:	aBluePen.CreatePen(PS_SOLID, 1, RGB(0, 0, 255) );
							pOldPen = (CPen *)pDC->SelectObject(&aBluePen);
					
							pdata->homegoalbottom = point;

							pDC->MoveTo(pdata->homegoaltop);
							pDC->LineTo(pdata->homegoalbottom.x, pdata->homegoaltop.y);
							pDC->LineTo(pdata->homegoalbottom);
							pDC->LineTo(pdata->homegoaltop.x, pdata->homegoalbottom.y);
							pDC->LineTo(pdata->homegoaltop);

							aBluePen.DeleteObject();

							break;

				//-- Case 2 ------> set opponent goal area
				case 2	:	aRedPen.CreatePen(PS_SOLID, 1, RGB(255, 0, 0) );
							pOldPen = (CPen *)pDC->SelectObject(&aRedPen);
					
							pdata->oppgoalbottom = point;

							pDC->MoveTo(pdata->oppgoaltop);
							pDC->LineTo(pdata->oppgoalbottom.x, pdata->oppgoaltop.y);
							pDC->LineTo(pdata->oppgoalbottom);
							pDC->LineTo(pdata->oppgoaltop.x, pdata->oppgoalbottom.y);
							pDC->LineTo(pdata->oppgoaltop);

							aRedPen.DeleteObject();

							break;
			} //-- end of switch statement

			pDC->SelectObject(pOldPen);	//-- select back the old pen
			ReleaseDC(pDC);
		}	//-- end of setting boundaries
	}
	else
	//-- If the point clicked is within the zoom window
	if (point.x >= ZoomWinX && point.x < ZoomWinX+200
		&& point.y >= 0 && point.y < 200 && pdata->start == FALSE)
	{

		Current = point;

		long redtotal=0, greentotal=0, bluetotal=0;
		BYTE averageRed, averageGreen, averageBlue;
		BYTE Xrange, Yrange;	//-- extent of the color box inside zoom window
		BYTE red, green, blue;
		int y, u, v;
		BYTE Ymin=255, Ymax=0, Umin=255, Umax=0, Vmin=255, Vmax=0;

		Xrange = (BYTE) (Current.x - Prev.x);
		Yrange = (BYTE) (Current.y - Prev.y);

		if (Xrange > 1 && Yrange > 1) //-- some pixels enclosed within the color box
		{
			CClientDC dc(this);
			LONG totalpixels = (Xrange-1) * (Yrange-1);
			COLORREF pixelcolor;

			//-- find the colour totals/Min and Max values --------
			for (int county=1; county<Yrange; county++)
			{
				for( int countx=1; countx<Xrange; countx++)
				{
					pixelcolor = dc.GetPixel(Prev.x+countx, Prev.y+county);

					red = GetRValue(pixelcolor);
					redtotal += red;
					green = GetGValue(pixelcolor);
					greentotal += green;
					blue = GetBValue(pixelcolor);
					bluetotal += blue;

					//-- calculate the YUV values from the RGB

					y = (299*red + 587*green + 114*blue + 500)/1000;
					u = (565*(blue - y) + 128000)/1000;
					v = (713*(red - y) + 128000)/1000;

					//-- calculate YUV Min/Max values --------------
					if ( y < Ymin ) Ymin = (BYTE) y;
					if ( y > Ymax ) Ymax = (BYTE) y;

					if ( u < Umin ) Umin = (BYTE) u;
					if ( u > Umax ) Umax = (BYTE) u;

					if ( v < Vmin ) Vmin = (BYTE) v;
					if ( v > Vmax ) Vmax = (BYTE) v;

				}	//-- end of inner for loop
			}	//-- end of outer for loop
			//-- now calculate the average RGB ----
			averageRed = (BYTE) (redtotal/totalpixels);
			averageGreen = (BYTE) (greentotal/totalpixels);
			averageBlue = (BYTE) (bluetotal/totalpixels);
			RGBColourBox = RGB(averageRed, averageGreen, averageBlue);
			//-- paint this colour in a rectangular box --
			dc.FillSolidRect(720, 210, 20, 20, RGBColourBox);
			m_Red = averageRed;
			m_Green = averageGreen;
			m_Blue = averageBlue;
			UpdateData(FALSE);  //-- transfer values from control 
								//-- variables to screen


			switch(m_ColourNRange)
			{
				//---- Ball selected for setting colour
				case 0	:	pdata->ballcol = RGBColourBox;
							pdata->ballcolR = averageRed;
							pdata->ballcolG = averageGreen;
							pdata->ballcolB = averageBlue;
							dc.FillSolidRect(640, 307, 15, 15, RGBColourBox);

							pdata->ballcolYmin = Ymin; pdata->ballcolYmax = Ymax;
							pdata->ballcolUmin = Umin; pdata->ballcolUmax = Umax;
							pdata->ballcolVmin = Vmin; pdata->ballcolVmax = Vmax;
							break;
				//---- Colour1 selected for setting colour
				case 1	:	pdata->robot1col = RGBColourBox;
							pdata->robot1colR = averageRed;
							pdata->robot1colG = averageGreen;
							pdata->robot1colB = averageBlue;
							dc.FillSolidRect(640, 330, 15, 15, RGBColourBox);

							pdata->robot1colYmin = Ymin; pdata->robot1colYmax = Ymax;
							pdata->robot1colUmin = Umin; pdata->robot1colUmax = Umax;
							pdata->robot1colVmin = Vmin; pdata->robot1colVmax = Vmax;
							break;
				//---- Colour2 selected for setting colour
				case 2	:	pdata->robot2col = RGBColourBox;
							pdata->robot2colR = averageRed;
							pdata->robot2colG = averageGreen;
							pdata->robot2colB = averageBlue;
							dc.FillSolidRect(640, 353, 15, 15, RGBColourBox);

							pdata->robot2colYmin = Ymin; pdata->robot2colYmax = Ymax;
							pdata->robot2colUmin = Umin; pdata->robot2colUmax = Umax;
							pdata->robot2colVmin = Vmin; pdata->robot2colVmax = Vmax;
							break;
				//---- Team selected for setting colour
				case 3	:	pdata->teamcol = RGBColourBox;
							pdata->teamcolR = averageRed;
							pdata->teamcolG = averageGreen;
							pdata->teamcolB = averageBlue;
							dc.FillSolidRect(640, 376, 15, 15, RGBColourBox);

							pdata->teamcolYmin = Ymin; pdata->teamcolYmax = Ymax;
							pdata->teamcolUmin = Umin; pdata->teamcolUmax = Umax;
							pdata->teamcolVmin = Vmin; pdata->teamcolVmax = Vmax;
							break;
				//---- Opponent selected for setting colour
				case 4	:	pdata->oppocol = RGBColourBox;
							pdata->oppocolR = averageRed;
							pdata->oppocolG = averageGreen;
							pdata->oppocolB = averageBlue;
							dc.FillSolidRect(640, 399, 15, 15, RGBColourBox);

							pdata->oppocolYmin = Ymin; pdata->oppocolYmax = Ymax;
							pdata->oppocolUmin = Umin; pdata->oppocolUmax = Umax;
							pdata->oppocolVmin = Vmin; pdata->oppocolVmax = Vmax;
							break;
			}	//-- end of switch statement
		}	//--  if (Xrange > 1 && Yrange > 1)
	}	//-- if (point.x >= ZoomWinX && point.x < ZoomWinX+200 ......

	//-- add more code here

	CDialog::OnLButtonUp(nFlags, point);
}

void CMyrosot1Dlg::OnLButtonDown(UINT nFlags, CPoint point) 
{
	if (pdata->start == TRUE)
		return;
	UpdateData(TRUE);	//-- transfer screen data to control variables

	//-- If the point clicked is within the capture window
	if (point.x >= 0 && point.x <= MaxX && point.y >= 0 && point.y <= MaxY)
	{
		if (m_Selection==1) //-- Set Boundaries Radio button has been chosen
		{
			switch(m_SetBoundary)
			{
				/* Case 0 ------> set field area */
				case 0	:	pdata->lefttop = point;
							break;
				/* Case 1 ------> set homegoal area */
				case 1	:	pdata->homegoaltop = point;
							break;
				/* Case 2 ------> set opponentgoal area */
				case 2	:	pdata->oppgoaltop = point;
							break;
			}	//-- end of switch statement
		}
	}
	else
	//-- If the point clicked is within the zoom window
	if (point.x >= ZoomWinX && point.x < ZoomWinX+200 && 
		point.y >= 0 && point.y < 200)
		Prev = point;

	//-- add more code here

	CDialog::OnLButtonDown(nFlags, point);
}


void CMyrosot1Dlg::OnRButtonDown(UINT nFlags, CPoint point) 
{
	UpdateData(TRUE);	//-- transfer screen data to control variables

	CString msg;

	//-- If the point clicked is within the capture window
	//-- show the screen and physical coordinates
	if (point.x >= 0 && point.x <= MaxX && point.y >= 0 && point.y <= MaxY)
	{
		floatPOINT Screen, Physical, Physical_Corrected_R, Physical_Corrected_B;
		Screen.x = (float)point.x;
		Screen.y = (float)point.y;

		//-- Convert the Screen coordinate to a Physical coordinate
		//-- based on BottomLeft (0,0) position
		mapxy(&Screen, &Physical, pdata);
		Physical_Corrected_R = parallaxCorrection(&Physical, pdata, (float)ROBOTHEIGHT);
		Physical_Corrected_B = parallaxCorrection(&Physical, pdata, (float)BALLHEIGHT);


		if (pdata->game_area == RIGHT_AREA)
			rotatemapxy(&Physical);

		msg.Format("Screen     X : %3d     Y : %3d pixels\nPhysical   X : %6.2f  Y : %6.2f cms"
			"\nRobot Corrected X : %6.2f  Y : %6.2f cms\nBall Corrected X : %6.2f  Y : %6.2f cms",
			(int)Screen.x, (int)Screen.y, Physical.x, Physical.y,
				Physical_Corrected_R.x, Physical_Corrected_R.y,
				 Physical_Corrected_B.x, Physical_Corrected_B.y);
		MessageBox(msg, "Screen/Physical Coordinates");
	}
	else
	//-- If the point clicked is within the zoom window
	//-- show the YUV values of the pixel clicked
	if (point.x >= 540 && point.x <= 739 && point.y >= 0 && point.y <= 199)
	{
		CClientDC dc(this);
		BYTE red, green, blue;
		int y, u, v;
		COLORREF pixelcolor;

		pixelcolor = dc.GetPixel(point.x, point.y);

		red = GetRValue(pixelcolor);
		green = GetGValue(pixelcolor);
		blue = GetBValue(pixelcolor);

		//-- calculate the YUV values from the RGB
		y = (299*red + 587*green + 114*blue + 500)/1000;
		u = (565*(blue - y) + 128000)/1000;
		v = (713*(red - y) + 128000)/1000;

		msg.Format("Y : %3d  U : %3d  V : %3d", y, u, v);
		MessageBox(msg, "YUV values");
	}
	else
	//-- clicked on the FullScan text
	//-- show the breakup of not found Goalie/Robot1/Robot2
	if (point.x >= 310 && point.x <= 360 && point.y >= 255 && point.y <= 275)
	{
		char str[40];
		sprintf(str, "Goalie : %3d\nRobot1 : %3d\nRobot2 : %3d",
			gNotFoundCount.Goalie,gNotFoundCount.Robot1,gNotFoundCount.Robot2);
		MessageBox(str, "Not Found");
	}

	CDialog::OnRButtonDown(nFlags, point);
}


void CMyrosot1Dlg::OnUpdatelutButton()
{
	//-- update the LUT --------------------
	int r, g, b;
	int y, u, v;
	char LUTclashMessage[80];
	BOOL LUTclash = FALSE;
	long index;
	HCURSOR hCursor;

	hCursor = AfxGetApp()->LoadStandardCursor(IDC_WAIT);
	SetCursor(hCursor);

	for (r=0; r<256; r++)
		for (g=0; g<256; g++)
			for (b=0; b<256; b++)
			{
				y = (299*r + 587*g + 114*b + 500)/1000;
				u = (565*(b - y) + 128000)/1000;
				v = (713*(r - y) + 128000)/1000;

				index = r*65536 + g*256 + b;
								
				LUT[index] = (BYTE) NoCOL; //initialise on update
				//-- ball range ----
				if ( ( (pdata->ballcolYmin<=y) && (y<=pdata->ballcolYmax) ) &&
				     ( (pdata->ballcolUmin<=u) && (u<=pdata->ballcolUmax) ) &&
				     ( (pdata->ballcolVmin<=v) && (v<=pdata->ballcolVmax) ) )
					LUT[index] = (BYTE) BALLCOL;
				
				//-- Colour1 range ----
				if ( ( (pdata->robot1colYmin<=y) && (y<=pdata->robot1colYmax) ) &&
				     ( (pdata->robot1colUmin<=u) && (u<=pdata->robot1colUmax) ) &&
				     ( (pdata->robot1colVmin<=v) && (v<=pdata->robot1colVmax) ) )

				{
					if(LUT[index] == NoCOL)
						LUT[index] = (BYTE) ROBOT1COL;
					else 
					{
						LUTclash = TRUE;
						sprintf(LUTclashMessage,"Clash updating Color1.\nClashed with color id:%d", LUT[index]);
					}
				}

				//-- Colour2 range ----
				if ( ( (pdata->robot2colYmin<=y) && (y<=pdata->robot2colYmax) ) &&
				     ( (pdata->robot2colUmin<=u) && (u<=pdata->robot2colUmax) ) &&
				     ( (pdata->robot2colVmin<=v) && (v<=pdata->robot2colVmax) ) )
				{
					if(LUT[index] == NoCOL)
						LUT[index] = (BYTE) ROBOT2COL;
					else 
					{
						LUTclash = TRUE;
						sprintf(LUTclashMessage,"Clash updating Color2.\nClashed with color id:%d", LUT[index]);
					}
				}

				//-- team range ----
				if ( ( (pdata->teamcolYmin<=y) && (y<=pdata->teamcolYmax) ) &&
				     ( (pdata->teamcolUmin<=u) && (u<=pdata->teamcolUmax) ) &&
				     ( (pdata->teamcolVmin<=v) && (v<=pdata->teamcolVmax) ) )
				{
					if(LUT[index] == NoCOL)
						LUT[index] = (BYTE) TEAMCOL;
					else 
					{
						LUTclash = TRUE;
						sprintf(LUTclashMessage,"Clash updating TEAM color.\nClashed with color id:%d", LUT[index]);
					}
				}

				//-- opponent range ------
				if ( ( (pdata->oppocolYmin<=y) && (y<=pdata->oppocolYmax) ) &&
				     ( (pdata->oppocolUmin<=u) && (u<=pdata->oppocolUmax) ) &&
				     ( (pdata->oppocolVmin<=v) && (v<=pdata->oppocolVmax) ) )
				{
					if(LUT[index] == NoCOL)
						LUT[index] = (BYTE) OPPOCOL;
					else 
					{
						LUTclash = TRUE;
						sprintf(LUTclashMessage,"Clash updating OPPO color.\nClashed with color id:%d", LUT[index]);
					}
				}
				
			} //-- end of for loop

	hCursor = AfxGetApp()->LoadStandardCursor(IDC_ARROW);
	SetCursor(hCursor);
	
	if(LUTclash)
	{
		MessageBox(LUTclashMessage);
	}
	else
	{
		pdata->LUTupdated = TRUE;
	}
}

void CMyrosot1Dlg::OnMouseMove(UINT nFlags, CPoint point) 
{
	//-- if the mouse moves over the zoom window with
	//-- the left mouse button pressed
	if (point.x >= 540 && point.x <= 739 && point.y >= 0 && point.y <= 199 &&
		(MK_LBUTTON & nFlags)==MK_LBUTTON )
	{
		CClientDC dc(this);

		//-- draw the picture in the zoom window --------
		int  pixelValue;
		BYTE red, green, blue;
		LPBYTE pZoomWinVar;

		pZoomWinVar = pZoomWin;	//-- make a copy of pZoomWin
								//-- pZoomWin must not be changed !!
		short i, j;
		short p, q;
		for(j=0; j<CAPSIZE*2; j++)
		{
			for(i=0; i<CAPSIZE*2; i++)
			{
				blue = *pZoomWinVar++;
				green = *pZoomWinVar++;
				red = *pZoomWinVar++;

				pixelValue = blue + (green<<8)+(red<<16);
				for (p=i*10; p<i*10+10; p++)
				{
					for(q=j*10; q<j*10+10; q++)
					{
						FB_SetVGAPixel(ZoomWinX+p, ZoomWinY+q, pixelValue);
					}
				}
			}
		}
		//-- end of drawing of the picture in the zoom window --------

		//-- now draw the lines

		dc.MoveTo(Prev);
		dc.LineTo(point.x, Prev.y);
		dc.LineTo(point);
		dc.LineTo(Prev.x, point.y);
		dc.LineTo(Prev);

	}
	else	//-- if the mouse moves over the capture window with
			//-- the left mouse button pressed and selection set to Set Boundaries
	if ( (m_Selection==1) && point.x >= 0 && point.x <= MaxX && point.y >= 0 && point.y <= MaxY &&
		(MK_LBUTTON & nFlags)==MK_LBUTTON )
	{
		CDC *pDC = GetDC();
		CPen aWhitePen, aBluePen, aRedPen, *pOldPen;

		switch(m_SetBoundary)
		{
			//-- Case 0 ------> draw field area
			case 0	:	aWhitePen.CreatePen(PS_SOLID, 1, RGB(255, 255, 255) );
						pOldPen = (CPen *)pDC->SelectObject(&aWhitePen);
					
						pDC->MoveTo(pdata->lefttop);
						pDC->LineTo(point.x, pdata->lefttop.y);
						pDC->LineTo(point);
						pDC->LineTo(pdata->lefttop.x, point.y);
						pDC->LineTo(pdata->lefttop);

						aWhitePen.DeleteObject();
						break;

			//-- Case 1 ------> draw homegoal area
			case 1	:	aBluePen.CreatePen(PS_SOLID, 1, RGB(0, 0, 255) );
						pOldPen = (CPen *)pDC->SelectObject(&aBluePen);
					
						pDC->MoveTo(pdata->homegoaltop);
						pDC->LineTo(point.x, pdata->homegoaltop.y);
						pDC->LineTo(point);
						pDC->LineTo(pdata->homegoaltop.x, point.y);
						pDC->LineTo(pdata->homegoaltop);

						aBluePen.DeleteObject();
						break;

			//-- Case 2 ------> draw opponent goal area
			case 2	:	aRedPen.CreatePen(PS_SOLID, 1, RGB(255, 0, 0) );
						pOldPen = (CPen *)pDC->SelectObject(&aRedPen);
				
						pDC->MoveTo(pdata->oppgoaltop);
						pDC->LineTo(point.x, pdata->oppgoaltop.y);
						pDC->LineTo(point);
						pDC->LineTo(pdata->oppgoaltop.x, point.y);
						pDC->LineTo(pdata->oppgoaltop);

						aRedPen.DeleteObject();
						break;
		} //-- end of switch statement

		pDC->SelectObject(pOldPen);	//-- select back the old pen
		ReleaseDC(pDC);
		//-- end of drawing boundaries

	}
	CDialog::OnMouseMove(nFlags, point);
}

void CMyrosot1Dlg::OnLeftRadio() 
{
	UpdateData(TRUE);
	pdata->game_area = LEFT_AREA;
}

void CMyrosot1Dlg::OnRightRadio() 
{
	UpdateData(TRUE);
	pdata->game_area = RIGHT_AREA;	
}

void CMyrosot1Dlg::OnOffRadio() 
{
	UpdateData(TRUE);
	pdata->diagnostics = OFF;
}

void CMyrosot1Dlg::OnLowRadio() 
{
	UpdateData(TRUE);
	pdata->diagnostics = LOW;
}

void CMyrosot1Dlg::OnHighRadio() 
{
	UpdateData(TRUE);
	pdata->diagnostics = HIGH;	
}

void CMyrosot1Dlg::OnMapcoloursRadio() 
{
	UpdateData(TRUE);
}

void CMyrosot1Dlg::OnSetboundariesRadio() 
{
	UpdateData(TRUE);
}

void CMyrosot1Dlg::OnFieldareaRadio() 
{
	UpdateData(TRUE);
	pdata->SetBoundary = 0;	//-- set the field area
}

void CMyrosot1Dlg::OnHomegoalareaRadio() 
{
	UpdateData(TRUE);
	pdata->SetBoundary = 1;	//-- set home goal area
}

void CMyrosot1Dlg::OnOppogoalareaRadio() 
{
	UpdateData(TRUE);
	pdata->SetBoundary = 2;	//-- set Opponent goal area
}

void CMyrosot1Dlg::OnDisplayCmRadio() 
{
	UpdateData(TRUE);
	pdata->update=TRUE;
	::PostMessage(pdata->pmainwindow->m_hWnd, WM_RBUTTONDBLCLK,NULL,NULL);
}

void CMyrosot1Dlg::OnDisplayPixelRadio() 
{
	UpdateData(TRUE);
	pdata->update=TRUE;
	::PostMessage(pdata->pmainwindow->m_hWnd, WM_RBUTTONDBLCLK,NULL,NULL);
}

void CMyrosot1Dlg::OnDisplayHomeRadio() 
{
	UpdateData(TRUE);
	pdata->update=TRUE;
	::PostMessage(pdata->pmainwindow->m_hWnd, WM_RBUTTONDBLCLK,NULL,NULL);	
}

void CMyrosot1Dlg::OnDisplayOppoRadio() 
{
	UpdateData(TRUE);
	pdata->update=TRUE;
	::PostMessage(pdata->pmainwindow->m_hWnd, WM_RBUTTONDBLCLK,NULL,NULL);	
}

void CMyrosot1Dlg::OnTestButton() 
{
	UpdateData(TRUE);

	switch (m_ColourNRange)
	{
	case 0 : //--Tuning Ball colour
				if (pdata->ballcol != 0)	//-- testing of ball is on
				{
					refcol = (BYTE) BALLCOL;
				}
				break;
	case 1 : //-- Tuning Colour1
				if (pdata->robot1col != 0)	//-- testing of robot1 is on
				{
					refcol = (BYTE) ROBOT1COL;
				}
				break;
	case 2 : //-- Tuning Colour2
				if (pdata->robot2col != 0)	//-- testing of robot2 is on
				{
					refcol = (BYTE) ROBOT2COL;
				}
				break;
	case 3 : //-- Tuning Team Colour
				if (pdata->teamcol != 0)	//-- testing of teamcolor is on
				{
					refcol = (BYTE) TEAMCOL;
				}
				break;
	case 4 : //-- Tuning Opponent colour
				if (pdata->oppocol != 0)	//-- testing of opponent colour is on
				{
					refcol = (BYTE) OPPOCOL;
				}
				break;
	}	//-- end of switch

	
	//	MessageBox("No colour selected\nfor the object to test");

	//-- install a timer
	int iInstallResult;
	iInstallResult = SetTimer(1, 800, NULL); //-- every 834 sec
	pdata->timer1_installed = TRUE;
}


void CMyrosot1Dlg::OnStoptestButton() 
{
	if (pdata->timer1_installed)
	{
		pdata->timer1_installed = FALSE;
		KillTimer(1);
	}

	//---- enable continuous streaming ----------
	if ( !FB_GetLiveStatus() )	//-- video is in NOT live
		FB_VideoLive(TRUE, ALIGN_ODD); //-- enable live video	
}

void CMyrosot1Dlg::OnTimer(UINT nIDEvent)
{
	if (nIDEvent == 1)	//-- colour testing is ON
	{
		int pixelcount = 0;	//-- count of pixel detected
		char pixelstr[20] = {' '};
		BYTE red, green, blue;
		int y, u, v;

		CClientDC dc(this);
		dc.SetBkMode( TRANSPARENT);
		dc.SetTextColor( RGB(255, 255, 255) );	//-- WHITE colour for text

		if (refcol == BALLCOL)	//-- testing of ball colour is on
		{
			refYmin = pdata->ballcolYmin;
			refYmax = pdata->ballcolYmax;
			refUmin = pdata->ballcolUmin;
			refUmax = pdata->ballcolUmax;
			refVmin = pdata->ballcolVmin;
			refVmax = pdata->ballcolVmax;
		}
		else
		if (refcol == ROBOT1COL)	//-- testing of robot1 colour is on
		{
			refYmin = pdata->robot1colYmin;
			refYmax = pdata->robot1colYmax;
			refUmin = pdata->robot1colUmin;
			refUmax = pdata->robot1colUmax;
			refVmin = pdata->robot1colVmin;
			refVmax = pdata->robot1colVmax;
		}
		else
		if (refcol == ROBOT2COL)	//-- testing of robot2 colour is on
		{
			refYmin = pdata->robot2colYmin;
			refYmax = pdata->robot2colYmax;
			refUmin = pdata->robot2colUmin;
			refUmax = pdata->robot2colUmax;
			refVmin = pdata->robot2colVmin;
			refVmax = pdata->robot2colVmax;
		}
		else
		if (refcol == TEAMCOL)	//-- testing of teamcolor is on
		{
			refYmin = pdata->teamcolYmin;
			refYmax = pdata->teamcolYmax;
			refUmin = pdata->teamcolUmin;
			refUmax = pdata->teamcolUmax;
			refVmin = pdata->teamcolVmin;
			refVmax = pdata->teamcolVmax;
		}
		else
		if (refcol == OPPOCOL)	//-- testing of opponent color is on
		{
			refYmin = pdata->oppocolYmin;
			refYmax = pdata->oppocolYmax;
			refUmin = pdata->oppocolUmin;
			refUmax = pdata->oppocolUmax;
			refVmin = pdata->oppocolVmin;
			refVmax = pdata->oppocolVmax;
		}

		LPBYTE pBmpdata;	//-- pointer to the bitmap

		pBmpdata = pCapData = lpImageBuf + (nCount*(DWORD)CapSizeX*CapSizeY*3L)
										 + sizeof(BITMAPINFOHEADER)+1024L;
		
		//-- scan only within the game area -------------------
		for (int row=pdata->lefttop.y; row<=pdata->rightbottom.y; row++)
		{
			pBmpdata = pCapData +
				(CapSizeX*row + pdata->lefttop.x)*3;
			
			for (int col=pdata->lefttop.x; col<=pdata->rightbottom.x; col++)
			{
				blue = *pBmpdata++;
				green = *pBmpdata++;
				red = *pBmpdata++;

				y = (299*red + 587*green + 114*blue + 500)/1000;
				u = (565*(blue - y) + 128000)/1000;
				v = (713*(red - y) + 128000)/1000;

				if ( ( (refYmin<=y) && (y<=refYmax) ) &&
				     ( (refUmin<=u) && (u<=refUmax) ) &&
				     ( (refVmin<=v) && (v<=refVmax) ) )
				//-- it is a desired pixel
				{
					pixelcount++;	//-- increase the pixel count
					//--dc.SetPixel(col, row, RGB(255,0,0) );
					FB_SetVGAPixel(col, row+VideoOriginY, RED);
				}
				else if (pdata->Bkcolour)
					//-- dc.SetPixel(col, row, RGB(0, 0, 0) );
					FB_SetVGAPixel(col, row+VideoOriginY, BLACK);

			} //-- end of inner for-loop
		} //-- end of outer for-loop

		sprintf(pixelstr, "#Pixels : %d", pixelcount);
		dc.TextOut(10, 10, pixelstr);
	}
	else

	if (nIDEvent == 2)	//-- adjusting boundaries
	{
		CClientDC dc(this);
		CPen aWhitePen, aRedPen, aBluePen, aYellowPen, *pOldPen;

		switch(globaldata.SetBoundary)
		{
		//--  Case 0 : display the boundaries of the game area
		case 0	:	aWhitePen.CreatePen(PS_SOLID, 1, RGB(255, 255, 255) );
					pOldPen = (CPen *)dc.SelectObject(&aWhitePen);

					dc.MoveTo(pdata->lefttop.x, pdata->lefttop.y);
					dc.LineTo(pdata->rightbottom.x, pdata->lefttop.y);
					dc.LineTo(pdata->rightbottom.x, pdata->rightbottom.y);
					dc.LineTo(pdata->lefttop.x, pdata->rightbottom.y);
					dc.LineTo(pdata->lefttop.x, pdata->lefttop.y);


					aWhitePen.DeleteObject();
					break;

		//--  Case 1 : display the boundaries of the home goal area
		case 1	:	aBluePen.CreatePen(PS_SOLID, 1, RGB(0, 0, 255) );
					pOldPen = (CPen *)dc.SelectObject(&aBluePen);

					dc.MoveTo(pdata->homegoaltop.x, pdata->homegoaltop.y);
					dc.LineTo(pdata->homegoalbottom.x, pdata->homegoaltop.y);
					dc.LineTo(pdata->homegoalbottom.x, pdata->homegoalbottom.y);
					dc.LineTo(pdata->homegoaltop.x, pdata->homegoalbottom.y);
					dc.LineTo(pdata->homegoaltop.x, pdata->homegoaltop.y);

					aBluePen.DeleteObject();
					break;

		//--  Case 2 : display the boundaries of the oppo goal area
		case 2	:	aRedPen.CreatePen(PS_SOLID, 1, RGB(255, 0, 0) );
					pOldPen = (CPen *)dc.SelectObject(&aRedPen);

					dc.MoveTo(pdata->oppgoaltop.x, pdata->oppgoaltop.y);
					dc.LineTo(pdata->oppgoalbottom.x, pdata->oppgoaltop.y);
					dc.LineTo(pdata->oppgoalbottom.x, pdata->oppgoalbottom.y);
					dc.LineTo(pdata->oppgoaltop.x, pdata->oppgoalbottom.y);
					dc.LineTo(pdata->oppgoaltop.x, pdata->oppgoaltop.y);

					aRedPen.DeleteObject();
					break;

		}	//-- end of switch statement

		//-- draw the centre lines
		aYellowPen.CreatePen(PS_SOLID, 1, RGB(255, 255, 0) );
		pOldPen = (CPen *)dc.SelectObject(&aYellowPen);
		dc.MoveTo(CapSizeX/2, 0);	
		dc.LineTo(CapSizeX/2, CapSizeY);
		dc.MoveTo(0, CapSizeY/2);
		dc.LineTo(CapSizeX, CapSizeY/2);


		dc.SelectObject(pOldPen);	//-- restore the old pen

	}	//-- if (nIDEvent == 2)	//-- adjusting boundaries
	
	timerCount=0;	//-- signal game handler that timer interrupt is generated
	CDialog::OnTimer(nIDEvent);
}

void CMyrosot1Dlg::OnBlackbackgroundCheck() 
{
	UpdateData(TRUE);
	pdata->Bkcolour = m_Bkcolour;
}

void CMyrosot1Dlg::OnDisplayboundariesCheck() 
{
	UpdateData(TRUE);
	pdata->DisplayBoundaries = m_DisplayBoundaries;
}

void CMyrosot1Dlg::OnFulltrackingonlyCheck() 
{
	UpdateData(TRUE);
	pdata->FullTrackingOnly = m_FullTrackingOnly;
}

void CMyrosot1Dlg::OnColortuningCheck() 
{
	UpdateData(TRUE);
	pdata->colTuning = m_colTuning;
}

void CMyrosot1Dlg::OnGetreadyButton()
{
	//-- OnGetReadyButton should not be effective if the
	//-- game has started
	if ( !pdata->start )
	{
		if (pdata->LUTupdated)
		{
			m_Diagnostics = pdata->diagnostics = LOW;	//-- diagnostics LOW
			m_DisplayBoundaries = pdata->DisplayBoundaries = TRUE;

			//-- Initialise Position and angle variables ---
			pdata->ballpos.x=0;	pdata->ballpos.y=0;
			pdata->goaliepos.x=0;pdata->goaliepos.y=0;
			pdata->robot1pos.x=0;pdata->robot1pos.y=0;
			pdata->robot2pos.x=0;pdata->robot2pos.y=0;

			pdata->teamcolpos1.x=0;	pdata->teamcolpos1.y=0;
			pdata->teamcolpos2.x=0;	pdata->teamcolpos2.y=0;
			pdata->teamcolpos3.x=0;	pdata->teamcolpos3.y=0;

			pdata->oppocolpos1.x=0;	pdata->oppocolpos1.y=0;
			pdata->oppocolpos2.x=0;	pdata->oppocolpos2.y=0;
			pdata->oppocolpos3.x=0;	pdata->oppocolpos3.y=0;

			pdata->oldballpos.x=0;pdata->oldballpos.y=0;
			pdata->oldgoaliepos.x=0;pdata->oldgoaliepos.y=0;
			pdata->oldrobot1pos.x=0;pdata->oldrobot1pos.y=0;
			pdata->oldrobot2pos.x=0;pdata->oldrobot2pos.y=0;

			pdata->ballvel.x=0;pdata->ballvel.y=0;
			pdata->goalievel.x=0;pdata->goalievel.y=0;
			pdata->robot1vel.x=0;pdata->robot1vel.y=0;
			pdata->robot2vel.x=0;pdata->robot2vel.y=0;

			pdata->goalieangle=0;
			pdata->robot1angle=0;
			pdata->robot2angle=0;
			//-- Initialisation of Position and Angle variables complete -

			//-- initialisation for strategy ---------
			pdata->ballposS.x = 0;	 pdata->ballposS.y = 0;
			pdata->goalieposS.x = 0; pdata->goalieposS.y = 0;
			pdata->robot1posS.x = 0; pdata->robot1posS.y = 0;
			pdata->robot2posS.x = 0; pdata->robot2posS.y = 0;
	
			pdata->oldballposS.x = 0;   pdata->oldballposS.y = 0;
			pdata->oldgoalieposS.x = 0; pdata->oldgoalieposS.y = 0;
			pdata->oldrobot1posS.x = 0; pdata->oldrobot1posS.y = 0;
			pdata->oldrobot2posS.x = 0; pdata->oldrobot2posS.y = 0;

			pdata->ballvelS.x = 0;   pdata->ballvelS.y = 0;
			pdata->goalievelS.x = 0; pdata->goalievelS.y = 0;
			pdata->robot1velS.x = 0; pdata->robot1velS.y = 0;
			pdata->robot2velS.x = 0; pdata->robot2velS.y = 0;

			pdata->goalieangleS = 0;
			pdata->robot1angleS = 0;
			pdata->robot2angleS = 0;

			//-- Initialisation for strategy complete here -----

			pdata->FullScan = m_FullScan = 0;	//-- initialise the counts
			pdata->Team = m_Team = 0;
			pdata->TeamFull = m_TeamFull = 0;
			pdata->Ball = m_Ball = 0;
			pdata->BallFull = m_BallFull = 0;
			pdata->FrameCount = m_FrameCount = 0;

			gNotFoundCount.Goalie = gNotFoundCount.Robot1
									= gNotFoundCount.Robot2 = 0;
			gRemoved.Goalie = m_ParametersDlg->m_GoalieRemoved;
			gRemoved.Robot1 = m_ParametersDlg->m_Robot1Removed;
			gRemoved.Robot2 = m_ParametersDlg->m_Robot2Removed;
			
			//-- Initialise the action states
			pdata->GState = 0;
			pdata->R1State = 0;
			pdata->R2State = 0;

			//---- PositionState initialisation
			pdata->PositionState = 2;		//-- Idle state is 2
	 

// Calculation of camera focus centre for the Parallax calculations
			floatPOINT  ScreenImageCentre;			
			
			ScreenImageCentre.x = CapSizeX/2;
			ScreenImageCentre.y = CapSizeY/2;
			mapxy(&ScreenImageCentre, &(pdata->PhysicalImageCentre), pdata);

			//-- pdata->fullFrame is TRUE at this point
			if(pdata->fullFrame)
			{
				fullTracking(pdata, FROMGETREADY);
				//-- Calculate strategy variables
				mapall(pdata);
			}
			//-- transfer the starting ball position
			pdata->StartBallPosS = pdata->ballposS;

			//-- update screen with Position and angles
			char msg[10] = {' '};
			char msg_Removed[10] = "Removed";
			char msg_XXXX[10] = "XXXX";

			if (m_DisplayHome == 0)	//-- display home position + angle
			{
				switch(m_DisplayUnit)	//-- display in CM or Pixels
				{
				//-- Case 0 : Display in CM
				case 0	:	sprintf(msg, "%7.2f",pdata->ballposS.x);
							m_Ballx = msg;
							sprintf(msg, "%7.2f",pdata->ballposS.y);
							m_Bally = msg;

							if (!gRemoved.Robot1)
							{
								sprintf(msg, "%7.2f",pdata->robot1posS.x);
								m_Robot1x = msg;
								sprintf(msg, "%7.2f",pdata->robot1posS.y);
								m_Robot1y = msg;
								sprintf(msg, "%7.2f",pdata->robot1angleS);
								m_Robot1angle = msg;
							}
							else
							{
								m_Robot1angle = msg_Removed;
								m_Robot1x = "";
								m_Robot1y = "";
							}

							if (!gRemoved.Robot2)
							{
								sprintf(msg, "%7.2f",pdata->robot2posS.x);
								m_Robot2x = msg;
								sprintf(msg, "%7.2f",pdata->robot2posS.y);
								m_Robot2y = msg;
								sprintf(msg, "%7.2f",pdata->robot2angleS);
								m_Robot2angle = msg;
							}
							else
							{
								m_Robot2angle = msg_Removed;
								m_Robot2x = "";
								m_Robot2y = "";
							}

							if (!gRemoved.Goalie)
							{
								sprintf(msg, "%7.2f",pdata->goalieposS.x);
								m_Goaliex = msg;
								sprintf(msg, "%7.2f",pdata->goalieposS.y);
								m_Goaliey = msg;
								sprintf(msg, "%7.2f",pdata->goalieangleS);
								m_Goalieangle = msg;
							}
							else
							{
								m_Goalieangle = msg_Removed;
								m_Goaliex = "";
								m_Goaliey = "";
							}

							break;

				//-- Case 1 : Display in Pixels
				case 1	:	sprintf(msg, "%7.2f",pdata->ballpos.x);
							m_Ballx = msg;
							sprintf(msg, "%7.2f",pdata->ballpos.y);
							m_Bally = msg;

							if (!gRemoved.Robot1)
							{
								sprintf(msg, "%7.2f",pdata->robot1pos.x);
								m_Robot1x = msg;
								sprintf(msg, "%7.2f",pdata->robot1pos.y);
								m_Robot1y = msg;
								sprintf(msg, "%7.2f",pdata->robot1angleS);
								m_Robot1angle = msg;
							}
							else
							{
								m_Robot1angle = msg_Removed;
								m_Robot1x = "";
								m_Robot1y = "";
							}

							if (!gRemoved.Robot2)
							{
								sprintf(msg, "%7.2f",pdata->robot2pos.x);
								m_Robot2x = msg;
								sprintf(msg, "%7.2f",pdata->robot2pos.y);
								m_Robot2y = msg;
								sprintf(msg, "%7.2f",pdata->robot2angleS);
								m_Robot2angle = msg;
							}
							else
							{
								m_Robot2angle = msg_Removed;
								m_Robot2x = "";
								m_Robot2y = "";
							}

							if (!gRemoved.Goalie)
							{
								sprintf(msg, "%7.2f",pdata->goaliepos.x);
								m_Goaliex = msg;
								sprintf(msg, "%7.2f",pdata->goaliepos.y);
								m_Goaliey = msg;
								sprintf(msg, "%7.2f",pdata->goalieangleS);
								m_Goalieangle = msg;
							}
							else
							{
								m_Goalieangle = msg_Removed;
								m_Goaliex = "";
								m_Goaliey = "";
							}

							break;
				}	//-- end of switch statement
			}
			else	//-- display opponent position & angle
			{
				//-- angle for the opponent robots is XXXX
				m_Robot1angle = msg_XXXX;
				m_Robot2angle = msg_XXXX;
				m_Goalieangle = msg_XXXX;

				switch(m_DisplayUnit)	//-- display in CM or pixels?
				{
					/* Case 0 ------> Display in cm */
					case 0	:	//-- display the ball position
								sprintf(msg, "%7.2f",pdata->ballposS.x);
								m_Ballx = msg;
								sprintf(msg, "%7.2f",pdata->ballposS.y);
								m_Bally = msg;

								//-- display the position of the opponent's first robot
								sprintf(msg, "%7.2f",pdata->opporobot1posS.x);
								m_Robot1x = msg;
								sprintf(msg, "%7.2f",pdata->opporobot1posS.y);
								m_Robot1y = msg;
							
								if (gNumOppoRobots > 1) //-- second robot
								{
									sprintf(msg, "%7.2f",pdata->opporobot2posS.x);
									m_Robot2x = msg;
									sprintf(msg, "%7.2f",pdata->opporobot2posS.y);
									m_Robot2y = msg;
								}

								if (gNumOppoRobots > 2)	//-- third robot
								{
									sprintf(msg, "%7.2f",pdata->opporobot3posS.x);
									m_Goaliex = msg;
									sprintf(msg, "%7.2f",pdata->opporobot3posS.y);
									m_Goaliey = msg;
								}

								break;

					/* Case 1 ------> Display in pixels */
					case 1	:	//-- display the ball position
								sprintf(msg, "%7.2f",pdata->ballpos.x);
								m_Ballx = msg;
								sprintf(msg, "%7.2f",pdata->ballpos.y);
								m_Bally = msg;

								//-- display the position of the first opponent's robot
								sprintf(msg, "%7.2f",pdata->oppocolpos1.x);
								m_Robot1x = msg;
								sprintf(msg, "%7.2f",pdata->oppocolpos1.y);
								m_Robot1y = msg;
								
								if (gNumOppoRobots > 1) //-- second robot
								{
									sprintf(msg, "%7.2f",pdata->oppocolpos2.x);
									m_Robot2x = msg;
									sprintf(msg, "%7.2f",pdata->oppocolpos2.y);
									m_Robot2y = msg;
								}

								if (gNumOppoRobots > 2)	//-- third robot
								{
									sprintf(msg, "%7.2f",pdata->oppocolpos3.x);
									m_Goaliex = msg;
									sprintf(msg, "%7.2f",pdata->oppocolpos3.y);
									m_Goaliey = msg;
								}

								break;
				} //-- end of switch statement
			}
			//------- OPPONENTS ----------------------------

			UpdateData(FALSE);	//-- Update screen

			//-- check the correctness of robot positioning -----------
			if (gStartingPosition.whosePossession == HOME)
			{
				if (gStartingPosition.StartPhase == KICKSTART)
				{
					if (pdata->robot1posS.x > pdata->robot2posS.x)
						MessageBox("Incorrect Robot Placement", "PLACEMENT ERROR", MB_ICONSTOP);
				}
				else
				if (gStartingPosition.StartPhase == PENALTY)
				{
					if (pdata->robot2posS.x < Physical_X/2 + 10)
						MessageBox("Incorrect STRIKER Placement", "PLACEMENT ERROR", MB_ICONSTOP);
				}
				else
				if (gStartingPosition.StartPhase == GOALKICK ||
					gStartingPosition.StartPhase == FREEKICK)
				{
					float dx, dy, ballTorobot2Distance;
					dx = pdata->ballposS.x - pdata->robot2posS.x;
					dy = pdata->ballposS.y - pdata->robot2posS.y;
					ballTorobot2Distance = (float)sqrt(dx*dx + dy*dy);
					if (ballTorobot2Distance > (float)(ROBOTWIDTH*2.0) )
						MessageBox("Incorrect STRIKER Placement", "PLACEMENT ERROR", MB_ICONSTOP);
				}
				else
				if (gStartingPosition.StartPhase == FREEBALL)
				{
					float dx, dy, ballTorobot2Distance;
					dx = pdata->ballposS.x - pdata->robot2posS.x;
					dy = pdata->ballposS.y - pdata->robot2posS.y;
					ballTorobot2Distance = (float)sqrt(dx*dx + dy*dy);
					if (ballTorobot2Distance > 25)
						MessageBox("Incorrect STRIKER Placement", "PLACEMENT ERROR", MB_ICONSTOP);
				}
			}
			//-- check the correctness of robot positioning -----------


			updateVariables(pdata);
			updateVariables(pdata);

			//-- pdata->fullFrame is TRUE at this point
			if(pdata->fullFrame)
			{
				//-- prepare to process odd/even fields separately
				//-- capture offscreen to 24 bpp 320 x 480 -------------
				if ( FB_VideoOffscreen(CapSizeX, CapSizeY*2, 24, TRUE) )
				{
					MessageBox("FB_VideoOffscreen() failed", "Error", MB_ICONSTOP);
					return;
				}
				
				pdata->fullFrame = FALSE;//-- process odd/even field

				pdata->colTuning = m_colTuning = FALSE;
				UpdateData(FALSE);
			}
		}
		else
			MessageBox("LUT not updated..", "LUT ERROR", MB_ICONSTOP);
	}

}	//-- OnGetreadyButton()


void CMyrosot1Dlg::OnStartButton()
{
	if (pdata->LUTupdated)
	{
		if(pdata->fullFrame) OnGetreadyButton();	//-- so that interrupt driven double buffering is enabled
		m_Diagnostics = pdata->diagnostics = LOW;	//-- diagnostics LOW
		m_DisplayBoundaries = pdata->DisplayBoundaries = FALSE;	//-- do not display boundaries

		pdata->start = TRUE;
		m_FrameCount = pdata->FrameCount = 0;
		UpdateData(FALSE);
	}
	else
		MessageBox("LUT not updated ....", "LUT ERROR", MB_ICONSTOP);
}	//-- OnStartButton()



void CMyrosot1Dlg::OnStopButton()
{
	pdata->start = FALSE;
	pdata->fullFrame = TRUE;	//-- process full image
	
	//-- capture offscreen to 24 bpp 320 x 240 -----------
	if (FBUSINSTALLED)
	{
		if ( FB_VideoOffscreen(CapSizeX, CapSizeY, 24, TRUE) )
		{
			MessageBox("FB_VideoOffscreen() failed", "Error", MB_ICONSTOP);
			return;
		}
	}
	//---- PositionState initialisation
	pdata->PositionState = 2;		//-- Idle state is 2

	pdata->colTuning = m_colTuning = TRUE;
	UpdateData(FALSE);

	//-- set all velocities to zero
	globaldata.packet[2] = 0x00;
	globaldata.packet[3] = 0x00;

	globaldata.packet[6] = 0x00;
	globaldata.packet[7] = 0x00;

	globaldata.packet[10] = 0x00;
	globaldata.packet[11] = 0x00;
	
	SendPacket();	//-- all robots stop

	//---- enable continuous streaming ----------
	if (!FB_GetLiveStatus()) //-- Video is NOT live
	{
		FB_VideoLive(TRUE, ALIGN_ODD);	//-- enable live video
		Delay(33); //-- put in a delay of 33 msec
	}

	return;
}

void CMyrosot1Dlg::OnSavecolorsButton()
{
	FILE *outfile;

	outfile = fopen("colours6.dat", "w");
	if (outfile == NULL)
	{
		MessageBox("Could not open file for saving ....");
		return;
	}

	fprintf(outfile, "%d\n", pdata->ballcolR);	//-- Ball
	fprintf(outfile, "%d\n", pdata->ballcolG);
	fprintf(outfile, "%d\n", pdata->ballcolB);

	fprintf(outfile, "%d\n", pdata->ballcolYmin);
	fprintf(outfile, "%d\n", pdata->ballcolYmax);
	fprintf(outfile, "%d\n", pdata->ballcolUmin);
	fprintf(outfile, "%d\n", pdata->ballcolUmax);
	fprintf(outfile, "%d\n", pdata->ballcolVmin);
	fprintf(outfile, "%d\n", pdata->ballcolVmax);

	fprintf(outfile, "%d\n", pdata->robot1colR);//-- Robot1
	fprintf(outfile, "%d\n", pdata->robot1colG);
	fprintf(outfile, "%d\n", pdata->robot1colB);

	fprintf(outfile, "%d\n", pdata->robot1colYmin);
	fprintf(outfile, "%d\n", pdata->robot1colYmax);
	fprintf(outfile, "%d\n", pdata->robot1colUmin);
	fprintf(outfile, "%d\n", pdata->robot1colUmax);
	fprintf(outfile, "%d\n", pdata->robot1colVmin);
	fprintf(outfile, "%d\n", pdata->robot1colVmax);

	fprintf(outfile, "%d\n", pdata->robot2colR);//-- Robot2
	fprintf(outfile, "%d\n", pdata->robot2colG);
	fprintf(outfile, "%d\n", pdata->robot2colB);

	fprintf(outfile, "%d\n", pdata->robot2colYmin);
	fprintf(outfile, "%d\n", pdata->robot2colYmax);
	fprintf(outfile, "%d\n", pdata->robot2colUmin);
	fprintf(outfile, "%d\n", pdata->robot2colUmax);
	fprintf(outfile, "%d\n", pdata->robot2colVmin);
	fprintf(outfile, "%d\n", pdata->robot2colVmax);

	fprintf(outfile, "%d\n", pdata->teamcolR);	//-- Team
	fprintf(outfile, "%d\n", pdata->teamcolG);
	fprintf(outfile, "%d\n", pdata->teamcolB);

	fprintf(outfile, "%d\n", pdata->teamcolYmin);
	fprintf(outfile, "%d\n", pdata->teamcolYmax);
	fprintf(outfile, "%d\n", pdata->teamcolUmin);
	fprintf(outfile, "%d\n", pdata->teamcolUmax);
	fprintf(outfile, "%d\n", pdata->teamcolVmin);
	fprintf(outfile, "%d\n", pdata->teamcolVmax);

	fprintf(outfile, "%d\n", pdata->oppocolR);	//-- opponent
	fprintf(outfile, "%d\n", pdata->oppocolG);
	fprintf(outfile, "%d\n", pdata->oppocolB);

	fprintf(outfile, "%d\n", pdata->oppocolYmin);
	fprintf(outfile, "%d\n", pdata->oppocolYmax);
	fprintf(outfile, "%d\n", pdata->oppocolUmin);
	fprintf(outfile, "%d\n", pdata->oppocolUmax);
	fprintf(outfile, "%d\n", pdata->oppocolVmin);
	fprintf(outfile, "%d\n", pdata->oppocolVmax);

	//-- store the boundaries of the game area
	fprintf(outfile, "%d\n", pdata->lefttop.x);
	fprintf(outfile, "%d\n", pdata->lefttop.y);
	fprintf(outfile, "%d\n", pdata->rightbottom.x);
	fprintf(outfile, "%d\n", pdata->rightbottom.y);

	//-- store the boundaries of the homegoal area
	fprintf(outfile, "%d\n", pdata->homegoaltop.x);
	fprintf(outfile, "%d\n", pdata->homegoaltop.y);
	fprintf(outfile, "%d\n", pdata->homegoalbottom.x);
	fprintf(outfile, "%d\n", pdata->homegoalbottom.y);

	//-- store the boundaries of the opponent goal area
	fprintf(outfile, "%d\n", pdata->oppgoaltop.x);
	fprintf(outfile, "%d\n", pdata->oppgoaltop.y);
	fprintf(outfile, "%d\n", pdata->oppgoalbottom.x);
	fprintf(outfile, "%d\n", pdata->oppgoalbottom.y);

	fclose(outfile);
}

void CMyrosot1Dlg::OnLoadcoloursButton()
{
	int nResponse;

	if (pdata->coloursLoaded)	//-- colour already loaded
	{
		//-- load colours if user wants it
		nResponse = MessageBox("Do you want to load colours?", "Load Colours",
							MB_ICONQUESTION|MB_YESNOCANCEL|MB_DEFBUTTON2);

		if (nResponse == IDCANCEL || nResponse == IDNO)	//-- if CANCEL or NO button pressed, return
			return;
	}

	if (!pdata->coloursLoaded || nResponse == IDYES)	//-- if YES button pressed or colours not loaded
	{

		FILE *infile;
		int temp;

		infile = fopen("colours6.dat", "r");
		if (infile == NULL)
		{
			MessageBox("Could not open file for reading ....");
			return;
		}

		//-- Ball
		fscanf(infile, "%d", &temp);	pdata->ballcolR = (BYTE)temp;
		fscanf(infile, "%d", &temp);	pdata->ballcolG = (BYTE)temp;
		fscanf(infile, "%d", &temp);	pdata->ballcolB = (BYTE)temp;
		pdata->ballcol = RGB(pdata->ballcolR, pdata->ballcolG, pdata->ballcolB);

		fscanf(infile, "%d", &temp);	pdata->ballcolYmin = (BYTE)temp;
		fscanf(infile, "%d", &temp);	pdata->ballcolYmax = (BYTE)temp;
		fscanf(infile, "%d", &temp);	pdata->ballcolUmin = (BYTE)temp;
		fscanf(infile, "%d", &temp);	pdata->ballcolUmax = (BYTE)temp;
		fscanf(infile, "%d", &temp);	pdata->ballcolVmin = (BYTE)temp;
		fscanf(infile, "%d", &temp);	pdata->ballcolVmax = (BYTE)temp;

		//-- Robot1
		fscanf(infile, "%d", &temp);	pdata->robot1colR = (BYTE)temp;
		fscanf(infile, "%d", &temp);	pdata->robot1colG = (BYTE)temp;
		fscanf(infile, "%d", &temp);	pdata->robot1colB = (BYTE)temp;
		pdata->robot1col = RGB(pdata->robot1colR, pdata->robot1colG, pdata->robot1colB);

		fscanf(infile, "%d", &temp);	pdata->robot1colYmin = (BYTE)temp;
		fscanf(infile, "%d", &temp);	pdata->robot1colYmax = (BYTE)temp;
		fscanf(infile, "%d", &temp);	pdata->robot1colUmin = (BYTE)temp;
		fscanf(infile, "%d", &temp);	pdata->robot1colUmax = (BYTE)temp;
		fscanf(infile, "%d", &temp);	pdata->robot1colVmin = (BYTE)temp;
		fscanf(infile, "%d", &temp);	pdata->robot1colVmax = (BYTE)temp;

		//-- Robot2
		fscanf(infile, "%d", &temp);	pdata->robot2colR = (BYTE)temp;
		fscanf(infile, "%d", &temp);	pdata->robot2colG = (BYTE)temp;
		fscanf(infile, "%d", &temp);	pdata->robot2colB = (BYTE)temp;
		pdata->robot2col = RGB(pdata->robot2colR, pdata->robot2colG, pdata->robot2colB);

		fscanf(infile, "%d", &temp);	pdata->robot2colYmin = (BYTE)temp;
		fscanf(infile, "%d", &temp);	pdata->robot2colYmax = (BYTE)temp;
		fscanf(infile, "%d", &temp);	pdata->robot2colUmin = (BYTE)temp;
		fscanf(infile, "%d", &temp);	pdata->robot2colUmax = (BYTE)temp;
		fscanf(infile, "%d", &temp);	pdata->robot2colVmin = (BYTE)temp;
		fscanf(infile, "%d", &temp);	pdata->robot2colVmax = (BYTE)temp;

		//-- Team
		fscanf(infile, "%d", &temp);	pdata->teamcolR = (BYTE)temp;
		fscanf(infile, "%d", &temp);	pdata->teamcolG = (BYTE)temp;
		fscanf(infile, "%d", &temp);	pdata->teamcolB = (BYTE)temp;
		pdata->teamcol = RGB(pdata->teamcolR, pdata->teamcolG, pdata->teamcolB);

		fscanf(infile, "%d", &temp);	pdata->teamcolYmin = (BYTE)temp;
		fscanf(infile, "%d", &temp);	pdata->teamcolYmax = (BYTE)temp;
		fscanf(infile, "%d", &temp);	pdata->teamcolUmin = (BYTE)temp;
		fscanf(infile, "%d", &temp);	pdata->teamcolUmax = (BYTE)temp;
		fscanf(infile, "%d", &temp);	pdata->teamcolVmin = (BYTE)temp;
		fscanf(infile, "%d", &temp);	pdata->teamcolVmax = (BYTE)temp;

		//-- Opponent
		fscanf(infile, "%d", &temp);	pdata->oppocolR = (BYTE)temp;
		fscanf(infile, "%d", &temp);	pdata->oppocolG = (BYTE)temp;
		fscanf(infile, "%d", &temp);	pdata->oppocolB = (BYTE)temp;
		pdata->oppocol = RGB(pdata->oppocolR, pdata->oppocolG, pdata->oppocolB);

		fscanf(infile, "%d", &temp);	pdata->oppocolYmin = (BYTE)temp;
		fscanf(infile, "%d", &temp);	pdata->oppocolYmax = (BYTE)temp;
		fscanf(infile, "%d", &temp);	pdata->oppocolUmin = (BYTE)temp;
		fscanf(infile, "%d", &temp);	pdata->oppocolUmax = (BYTE)temp;
		fscanf(infile, "%d", &temp);	pdata->oppocolVmin = (BYTE)temp;
		fscanf(infile, "%d", &temp);	pdata->oppocolVmax = (BYTE)temp;

		//-- read the game area boundaries
		fscanf(infile, "%d", &temp);	pdata->lefttop.x = temp;
		fscanf(infile, "%d", &temp);	pdata->lefttop.y = temp;
		fscanf(infile, "%d", &temp);	pdata->rightbottom.x = temp;
		fscanf(infile, "%d", &temp);	pdata->rightbottom.y = temp;

		//-- read the home goal area boundaries
		fscanf(infile, "%d", &temp);	pdata->homegoaltop.x = temp;
		fscanf(infile, "%d", &temp);	pdata->homegoaltop.y = temp;
		fscanf(infile, "%d", &temp);	pdata->homegoalbottom.x = temp;
		fscanf(infile, "%d", &temp);	pdata->homegoalbottom.y = temp;

		//-- read the opponent goal area boundaries
		fscanf(infile, "%d", &temp);	pdata->oppgoaltop.x = temp;
		fscanf(infile, "%d", &temp);	pdata->oppgoaltop.y = temp;
		fscanf(infile, "%d", &temp);	pdata->oppgoalbottom.x = temp;
		fscanf(infile, "%d", &temp);	pdata->oppgoalbottom.y = temp;

		fclose(infile);

		//-- now update the LUT --------------------
		OnUpdatelutButton();

		//-- draw the colour boxes
		CClientDC dc(this);

		if (pdata->ballcol != 0)
			dc.FillSolidRect(640, 307, 15, 15, pdata->ballcol);
		if (pdata->robot1col != 0)
			dc.FillSolidRect(640, 330, 15, 15, pdata->robot1col);
		if (pdata->robot2col != 0)
			dc.FillSolidRect(640, 353, 15, 15, pdata->robot2col);
		if (pdata->teamcol != 0)
			dc.FillSolidRect(640, 376, 15, 15, pdata->teamcol);
		if (pdata->oppocol != 0)
			dc.FillSolidRect(640, 399, 15, 15, pdata->oppocol);

		pdata->coloursLoaded = TRUE;
	}
}

void CMyrosot1Dlg::OnLButtonDblClk(UINT nFlags, CPoint point) 
{
	CString msgStr, msgTimeStr;
	CString msgStrR1, msgStrR2;
	int labelX, labelY;	//-- coordinates at which the label is displayed

	switch(pdata->GState)
	{
	case 1	:	msgStr = "G - Clear Ball";
				break;
	case 2	:	msgStr = "G - Track Ball";
				break;
	case 3	:	msgStr = "G - Centre in goal";
				break;
	default :	msgStr = "G - No state!!";
				break;
	}

	m_Observer = msgStr;

	//-- display the time taken for processing --------
	msgTimeStr.Format("%lu", pdata->timeDiff);
	m_Time = msgTimeStr;
	//-------------------------------------------------

	CClientDC objDC(this);
	COLORREF myColour;
	int nSaveDC = objDC.SaveDC();

	objDC.SetBkMode(TRANSPARENT);

	//-- display the robot labels ----------
	objDC.SetTextColor( RGB(255, 255, 255) );	//-- WHITE colour for text

	if (!gRemoved.Goalie)
	{
		if (pdata->goaliepos.x < 10)	//-- inside 10 pixels of left edge
			labelX = (int)pdata->goaliepos.x+5;
		else
			labelX = (int)pdata->goaliepos.x-5;
		if (pdata->goaliepos.y > MaxY-15) //-- within 15 pixels of bottom edge
			labelY = (int)pdata->goaliepos.y-5;
		else
			labelY = (int)pdata->goaliepos.y+5;

		objDC.TextOut(labelX, labelY, "G");
	}

	if (!gRemoved.Robot1)
	{
		if (pdata->robot1pos.x < 10)	//-- inside 10 pixels of left edge
			labelX = (int)pdata->robot1pos.x+5;
		else
			labelX = (int)pdata->robot1pos.x-5;
		if (pdata->robot1pos.y > MaxY-15) //-- within 15 pixels of bottom edge
			labelY = (int)pdata->robot1pos.y-5;
		else
			labelY = (int)pdata->robot1pos.y+5;

		objDC.TextOut(labelX, labelY, "1");
	}

	if (!gRemoved.Robot2)
	{
		if (pdata->robot2pos.x < 10)	//-- inside 10 pixels of left edge
			labelX = (int)pdata->robot2pos.x+5;
		else
			labelX = (int)pdata->robot2pos.x-5;
		if (pdata->robot2pos.y > MaxY-15) //-- within 15 pixels of bottom edge
			labelY = (int)pdata->robot2pos.y-5;
		else
			labelY = (int)pdata->robot2pos.y+5;

		objDC.TextOut(labelX, labelY, "2");
	}

	//-- display the ball label -------------
	if (pdata->ballpos.x < 10)	//-- inside 10 pixels of left edge
		labelX = (int)pdata->ballpos.x+5;
	else
		labelX = (int)pdata->ballpos.x-5;
	if (pdata->ballpos.y > MaxY-15) //-- within 15 pixels of bottom edge
		labelY = (int)pdata->ballpos.y-5;
	else
		labelY = (int)pdata->ballpos.y+5;

	objDC.TextOut(labelX, labelY, "B");
	myColour = RGB(255, 150, 0);
	objDC.FillSolidRect((int)pdata->ballpos.x-2, (int)pdata->ballpos.y-2, 4, 4, myColour);

	//ELLIOT
	myColour = RGB(50, 50, 255);
	objDC.FillSolidRect((int)pdata->predicted.x-2, (int)pdata->predicted.y-2, 4, 4, myColour);
	m_Robot1angle.Format("%7.2f", pdata->ballAngleAve);

	//-- display the opponent robot labels
	if (gTrackOpponent)
	{
		objDC.TextOut( (int)(pdata->oppocolpos1.x),
						(int)(pdata->oppocolpos1.y), "O1");
		if (gNumOppoRobots >1)
			objDC.TextOut( (int)(pdata->oppocolpos2.x),
						(int)(pdata->oppocolpos2.y), "O2");

		if (gNumOppoRobots >2)
			objDC.TextOut( (int)(pdata->oppocolpos3.x),
						(int)(pdata->oppocolpos3.y), "O3");
	}

	objDC.RestoreDC(nSaveDC);

	UpdateData(FALSE);

	CDialog::OnLButtonDblClk(nFlags, point);
}



void CMyrosot1Dlg::OnRButtonDblClk(UINT nFlags, CPoint point) 
{
	if(pdata->update==TRUE)
	{
		//-- update screen with Position and angles
		char msg[10] = {' '};
		char msg_Removed[10] = "Removed";
		char msg_XXXX[10] = "XXXX";

		if (m_DisplayHome == 0)	//-- display home position + angle
		{
			switch(m_DisplayUnit)	//-- display in CM or Pixels
			{
			//-- Case 0 : Display in CM
			case 0	:	sprintf(msg, "%7.2f",pdata->ballposS.x);
						m_Ballx = msg;
						sprintf(msg, "%7.2f",pdata->ballposS.y);
						m_Bally = msg;

						if (!gRemoved.Robot1)
						{
							sprintf(msg, "%7.2f",pdata->robot1posS.x);
							m_Robot1x = msg;
							sprintf(msg, "%7.2f",pdata->robot1posS.y);
							m_Robot1y = msg;
							sprintf(msg, "%7.2f",pdata->robot1angleS);
							m_Robot1angle = msg;
						}
						else
						{
							m_Robot1angle = msg_Removed;
							m_Robot1x = "";
							m_Robot1y = "";
						}

						if (!gRemoved.Robot2)
						{
							sprintf(msg, "%7.2f",pdata->robot2posS.x);
							m_Robot2x = msg;
							sprintf(msg, "%7.2f",pdata->robot2posS.y);
							m_Robot2y = msg;
							sprintf(msg, "%7.2f",pdata->robot2angleS);
							m_Robot2angle = msg;
						}
						else
						{
							m_Robot2angle = msg_Removed;
							m_Robot2x = "";
							m_Robot2y = "";
						}

						if (!gRemoved.Goalie)
						{
							sprintf(msg, "%7.2f",pdata->goalieposS.x);
							m_Goaliex = msg;
							sprintf(msg, "%7.2f",pdata->goalieposS.y);
							m_Goaliey = msg;
							sprintf(msg, "%7.2f",pdata->goalieangleS);
							m_Goalieangle = msg;
						}
						else
						{
							m_Goalieangle = msg_Removed;
							m_Goaliex = "";
							m_Goaliey = "";
						}

						break;

			//-- Case 1 : Display in Pixels
			case 1	:	sprintf(msg, "%7.2f",pdata->ballpos.x);
						m_Ballx = msg;
						sprintf(msg, "%7.2f",pdata->ballpos.y);
						m_Bally = msg;

						if (!gRemoved.Robot1)
						{
							sprintf(msg, "%7.2f",pdata->robot1pos.x);
							m_Robot1x = msg;
							sprintf(msg, "%7.2f",pdata->robot1pos.y);
							m_Robot1y = msg;
							sprintf(msg, "%7.2f",pdata->robot1angleS);
							m_Robot1angle = msg;
						}
						else
						{
							m_Robot1angle = msg_Removed;
							m_Robot1x = "";
							m_Robot1y = "";
						}

						if (!gRemoved.Robot2)
						{
							sprintf(msg, "%7.2f",pdata->robot2pos.x);
							m_Robot2x = msg;
							sprintf(msg, "%7.2f",pdata->robot2pos.y);
							m_Robot2y = msg;
							sprintf(msg, "%7.2f",pdata->robot2angleS);
							m_Robot2angle = msg;
						}
						else
						{
							m_Robot2angle = msg_Removed;
							m_Robot2x = "";
							m_Robot2y = "";
						}

						if (!gRemoved.Goalie)
						{
							sprintf(msg, "%7.2f",pdata->goaliepos.x);
							m_Goaliex = msg;
							sprintf(msg, "%7.2f",pdata->goaliepos.y);
							m_Goaliey = msg;
							sprintf(msg, "%7.2f",pdata->goalieangleS);
							m_Goalieangle = msg;
						}
						else
						{
							m_Goalieangle = msg_Removed;
							m_Goaliex = "";
							m_Goaliey = "";
						}

						break;
			}	//-- end of switch statement
		}
		else	//-- display opponent position & angle
		{
			//-- angle for the opponent robots is XXXX
			m_Robot1angle = msg_XXXX;
			m_Robot2angle = msg_XXXX;
			m_Goalieangle = msg_XXXX;

			switch(m_DisplayUnit)	//-- display in CM or pixels?
			{
				/* Case 0 ------> Display in cm */
				case 0	:	//-- display the ball position
							sprintf(msg, "%7.2f",pdata->ballposS.x);
							m_Ballx = msg;
							sprintf(msg, "%7.2f",pdata->ballposS.y);
							m_Bally = msg;

							//-- display the position of the opponent's first robot
							sprintf(msg, "%7.2f",pdata->opporobot1posS.x);
							m_Robot1x = msg;
							sprintf(msg, "%7.2f",pdata->opporobot1posS.y);
							m_Robot1y = msg;
							
							if (gNumOppoRobots > 1) //-- second robot
							{
								sprintf(msg, "%7.2f",pdata->opporobot2posS.x);
								m_Robot2x = msg;
								sprintf(msg, "%7.2f",pdata->opporobot2posS.y);
								m_Robot2y = msg;
							}

							if (gNumOppoRobots > 2)	//-- third robot
							{
								sprintf(msg, "%7.2f",pdata->opporobot3posS.x);
								m_Goaliex = msg;
								sprintf(msg, "%7.2f",pdata->opporobot3posS.y);
								m_Goaliey = msg;
							}

							break;

				/* Case 1 ------> Set Display in pixels */
				case 1	:	//-- display the ball position
							sprintf(msg, "%7.2f",pdata->ballpos.x);
							m_Ballx = msg;
							sprintf(msg, "%7.2f",pdata->ballpos.y);
							m_Bally = msg;

							//-- display the position of the first opponent's robot
							sprintf(msg, "%7.2f",pdata->oppocolpos1.x);
							m_Robot1x = msg;
							sprintf(msg, "%7.2f",pdata->oppocolpos1.y);
							m_Robot1y = msg;
							
							if (gNumOppoRobots > 1) //-- second robot
							{
								sprintf(msg, "%7.2f",pdata->oppocolpos2.x);
								m_Robot2x = msg;
								sprintf(msg, "%7.2f",pdata->oppocolpos2.y);
								m_Robot2y = msg;
							}

							if (gNumOppoRobots > 2)	//-- third robot
							{
								sprintf(msg, "%7.2f",pdata->oppocolpos3.x);
								m_Goaliex = msg;
								sprintf(msg, "%7.2f",pdata->oppocolpos3.y);
								m_Goaliey = msg;
							}

							break;
			} //-- end of switch statement
		}
		//------- OPPONENTS ----------------------------

		//-- update screen with counts -------------
		m_FullScan = pdata->FullScan;
		m_Team = pdata->Team;
		m_TeamFull = pdata->TeamFull;
		m_Ball = pdata->Ball;
		m_BallFull = pdata->BallFull;
		m_FrameCount = pdata->FrameCount;
		
		UpdateData(FALSE);
		pdata->update=FALSE;
	}

	CDialog::OnRButtonDblClk(nFlags, point);
}

void CMyrosot1Dlg::OnAdjustrangeButton() 
{
	//-- disable black background before popping the YUV 
	//-- adjustment window
	m_Bkcolour = pdata->Bkcolour = false;
	UpdateData(FALSE);

	m_AdjColDlg->DoModal();	//-- create the Adjust Colour Dialog Box

	m_Bkcolour = pdata->Bkcolour;
	UpdateData(FALSE);
}

void CMyrosot1Dlg::OnGrabberSettings() 
{
	//-- invoke the settings form
	m_GrabberSettingsDlg->DoModal();	
}

void CMyrosot1Dlg::OnKickstartRadio() 
{
	UpdateData(TRUE);
	gStartingPosition.StartPhase = KICKSTART;

	gVelocityScaling = (float)VELOCITYSCALING;

	UpdateData(FALSE);
}

void CMyrosot1Dlg::OnGoalkickRadio() 
{
	UpdateData(TRUE);
	gStartingPosition.StartPhase = GOALKICK;

	gVelocityScaling = (float)VELOCITYSCALING;

	UpdateData(FALSE);
}

void CMyrosot1Dlg::OnPenaltyRadio() 
{
	UpdateData(TRUE);
	gStartingPosition.StartPhase = PENALTY;

	//-- if the penalty is taken by the opponent team and
	//-- home goalie should follow the clicked point, then
	//-- increase the velocity scaling factor to seed up the goalie
	if (gStartingPosition.whosePossession == OPPONENT &&
		gGoalieFollowClick)
		gVelocityScaling = gVelocityScaling*(float)1.08;

	UpdateData(FALSE);
}

void CMyrosot1Dlg::OnFreekickRadio() 
{
	UpdateData(TRUE);
	gStartingPosition.StartPhase = FREEKICK;

	gVelocityScaling = (float)VELOCITYSCALING;

	UpdateData(FALSE);
}

void CMyrosot1Dlg::OnFreeballRadio() 
{
	UpdateData(TRUE);
	gStartingPosition.StartPhase = FREEBALL;

	gVelocityScaling = (float)VELOCITYSCALING;

	UpdateData(FALSE);
}

void CMyrosot1Dlg::OnHomeRadio() 
{
	UpdateData(TRUE);
	gStartingPosition.whosePossession = HOME;

	gVelocityScaling = (float)VELOCITYSCALING;

	UpdateData(FALSE);
}

void CMyrosot1Dlg::OnOpponentRadio() 
{
	UpdateData(TRUE);
	gStartingPosition.whosePossession = OPPONENT;

	//-- if the opponent team is taking penalty and
	//-- home goalie should follow the clicked point, then
	//-- increase the velocity scaling factor to seed up the goalie
	if (gStartingPosition.StartPhase == PENALTY &&
		gGoalieFollowClick)
		gVelocityScaling = gVelocityScaling*(float)1.08;

	UpdateData(FALSE);
}

void CMyrosot1Dlg::OnTopleftRadio() 
{
	UpdateData(TRUE);
	gStartingPosition.whichQuadrant = TOPLEFT;
}

void CMyrosot1Dlg::OnToprightRadio() 
{
	UpdateData(TRUE);
	gStartingPosition.whichQuadrant = TOPRIGHT;
}

void CMyrosot1Dlg::OnBottomleftRadio() 
{
	UpdateData(TRUE);
	gStartingPosition.whichQuadrant = BOTTOMLEFT;
}

void CMyrosot1Dlg::OnBottomrightRadio() 
{
	UpdateData(TRUE);
	gStartingPosition.whichQuadrant = BOTTOMRIGHT;
}

void CMyrosot1Dlg::OnBallRadio() 
{
	UpdateData(TRUE);
	if (pdata->ballcol != 0)	//-- testing of ball is on
		refcol = (BYTE) BALLCOL;
}

void CMyrosot1Dlg::OnRobot1Radio() 
{
	UpdateData(TRUE);
	if (pdata->robot1col != 0)	//-- testing of robot1 is on
		refcol = (BYTE) ROBOT1COL;
}

void CMyrosot1Dlg::OnRobot2Radio() 
{
	UpdateData(TRUE);
	if (pdata->robot2col != 0)	//-- testing of robot2 is on
		refcol = (BYTE) ROBOT2COL;
}

void CMyrosot1Dlg::OnTeamRadio() 
{
	UpdateData(TRUE);
	if (pdata->teamcol != 0)	//-- testing of teamcolor is on
		refcol = (BYTE) TEAMCOL;
}

void CMyrosot1Dlg::OnOppoRadio() 
{
	UpdateData(TRUE);
	if (pdata->oppocol != 0)	//-- testing of opponent colour is on
		refcol = (BYTE) OPPOCOL;
}

void CMyrosot1Dlg::OnGoButton() 
{
	pdata->PositionState = 0;	//-- robots not in desired final positions
								//-- so the gameHandler() can call placeRobots()
	if(pdata->fullFrame)
	{
		//-- prepare to process odd/even fields separately
		//-- capture offscreen to 24 bpp 320 x 480 -------------
		if ( FB_VideoOffscreen(CapSizeX, CapSizeY*2, 24, TRUE) )
		{
			MessageBox("FB_VideoOffscreen() failed", "Error", MB_ICONSTOP);
			return;
		}

		pdata->fullFrame = FALSE; //-- process odd/even field

		pdata->colTuning = m_colTuning = FALSE;
	}
	UpdateData(FALSE);
}

void CMyrosot1Dlg::OnQstateButton() 
{
	//-- returns the starting phase to Kick Start and
	//-- possession to Home Team

	//-- initialisation of placement status ---------------------
	m_startPhase = gStartingPosition.StartPhase = KICKSTART;
	m_whosePossession = gStartingPosition.whosePossession = HOME;
	m_whichQuadrant = gStartingPosition.whichQuadrant = TOPLEFT;
	//-----------------------------------------------------------

	gVelocityScaling = (float)VELOCITYSCALING;
	gSpinVelocityScaling = (float)SPINVELOCITYSCALING;

	UpdateData(FALSE);
}

void CMyrosot1Dlg::OnDestroy() 
{
	CDialog::OnDestroy();
	
	//-- set all velocities to zero
	globaldata.packet[2] = 0x00;
	globaldata.packet[3] = 0x00;

	globaldata.packet[6] = 0x00;
	globaldata.packet[7] = 0x00;

	globaldata.packet[10] = 0x00;
	globaldata.packet[11] = 0x00;
	
	SendPacket();	//-- all robots stop

	//-- Disable interrupt
	if (pdata->IRQEnabled)
	{
		FB_EnableIRQ(INTTYPE, wIRQNum, false, gameHandler);
		pdata->IRQEnabled = false;
	}

	//--  release memory
	if (lpImageBuf)
	{
	  CapMemInfo.dwMemPtr=(DWORD)lpImageBuf;
	  CapMemInfo.dwMemSize=0x200000;
	  FB_VideoCaptureMem(&CapMemInfo, VCM_RELEASEMEMBUFFER);
	}

	//-- cleanup the Flash Bus grabber card
	FB_Cleanup();
}

void displayBoundaries(void)
{
	commondata *pdata = &globaldata;

	CClientDC dc(pdata->pmainwindow);

	//--  display the various boundaries --------------
	CPen aWhitePen, aRedPen, aBluePen, aYellowPen, *pOldPen;

	aWhitePen.CreatePen(PS_SOLID, 1, RGB(255, 255, 255) );
	aRedPen.CreatePen(PS_SOLID, 1, RGB(255, 0, 0) );
	aBluePen.CreatePen(PS_SOLID, 1, RGB(0, 0, 255) );
	aYellowPen.CreatePen(PS_SOLID, 1, RGB(255, 255, 0) );

	//--  display the boundaries of the game area
	pOldPen = (CPen *)dc.SelectObject(&aWhitePen);

	dc.MoveTo(pdata->lefttop.x, pdata->lefttop.y);
	dc.LineTo(pdata->rightbottom.x, pdata->lefttop.y);
	dc.LineTo(pdata->rightbottom.x, pdata->rightbottom.y);
	dc.LineTo(pdata->lefttop.x, pdata->rightbottom.y);
	dc.LineTo(pdata->lefttop.x, pdata->lefttop.y);

	dc.MoveTo(pdata->homegoaltop.x, pdata->lefttop.y);
	dc.LineTo(pdata->homegoaltop.x, pdata->rightbottom.y);
	dc.MoveTo(pdata->oppgoalbottom.x, pdata->lefttop.y);
	dc.LineTo(pdata->oppgoalbottom.x, pdata->rightbottom.y);

	//-- restore the old pen ---------
	dc.SelectObject(pOldPen);
	aWhitePen.DeleteObject();

	//--  display the boundaries of the home goal area
	pOldPen = (CPen *)dc.SelectObject(&aBluePen);

	dc.MoveTo(pdata->homegoaltop.x, pdata->homegoaltop.y);
	dc.LineTo(pdata->homegoalbottom.x, pdata->homegoaltop.y);
	dc.LineTo(pdata->homegoalbottom.x, pdata->homegoalbottom.y);
	dc.LineTo(pdata->homegoaltop.x, pdata->homegoalbottom.y);
	dc.LineTo(pdata->homegoaltop.x, pdata->homegoaltop.y);


	//-- restore the old pen ---------
	dc.SelectObject(pOldPen);
	aBluePen.DeleteObject();

	//--  display the boundaries of the opponent goal area
	pOldPen = (CPen *)dc.SelectObject(&aRedPen);

	dc.MoveTo(pdata->oppgoaltop.x, pdata->oppgoaltop.y);
	dc.LineTo(pdata->oppgoalbottom.x, pdata->oppgoaltop.y);
	dc.LineTo(pdata->oppgoalbottom.x, pdata->oppgoalbottom.y);
	dc.LineTo(pdata->oppgoaltop.x, pdata->oppgoalbottom.y);
	dc.LineTo(pdata->oppgoaltop.x, pdata->oppgoaltop.y);

	//-- restore the old pen ---------
	dc.SelectObject(pOldPen);
	aRedPen.DeleteObject();

	//-- draw the centre lines in Yellow
	pOldPen = (CPen *)dc.SelectObject(&aYellowPen);

	dc.MoveTo(CapSizeX/2, 0);	
	dc.LineTo(CapSizeX/2, CapSizeY);
	dc.MoveTo(0, CapSizeY/2);
	dc.LineTo(CapSizeX, CapSizeY/2);

	//-- Draw the centre circle
	floatPOINT circlePt, circlePtS;
	float angle;
	circlePtS.x = Physical_Xby2 + 20;
	circlePtS.y = Physical_Yby2;
	//-- map physical coordinates to screen coordinates
	PhysicaltoScreen(&circlePt, &circlePtS, pdata);
	dc.MoveTo( (int) circlePt.x, (int) circlePt.y);	//-- move to the starting point

	for (angle = 2; angle <= 360; angle = angle + 2)
	{
		circlePtS.x = Physical_Xby2 + (float) (20.0 * cos(angle*PI/180) );
		circlePtS.y = Physical_Yby2 + (float) (20.0 * sin(angle*PI/180) );
		//-- map physical coordinates to screen coordinates
		PhysicaltoScreen(&circlePt, &circlePtS, pdata);
		dc.LineTo((int) circlePt.x, (int) circlePt.y);
	}

	//-- restore the old pen -----------
	dc.SelectObject(pOldPen);
	aYellowPen.DeleteObject();
}	//-- displayBoundaries()

//----------- Game Handler ------------------------------
void gameHandler()
{
	//-- this function is called every time there is VSYNC

	static commondata *pdata = &globaldata;

	static int count=0;
	static int nNextCount;
	static DWORD present, past=0;
	static char timestr[40] = {' '};
	static DWORD halfFrameTime = 0;
	static float halfFrameCount;
	static DWORD oddEvenTime=0;
	static BOOL GameStarting=FALSE;
	
	present = timeGetTime();
	
	halfFrameTime = present - past;
	
	if (halfFrameTime>24 && past!=0)
	{
		//-- more than one half frame has passed
		halfFrameCount = (float) (halfFrameTime*5.994/100);//-- NTSC is 59.94Hz
		halfFrameJump = (int) (halfFrameCount + 0.5);
		count += (int)(halfFrameCount-1 + 0.4);
		count%=2;
	}
	else
	{
		halfFrameJump = 1;
	}

	past = present;
 	//-- Should be count==0 on even field
	if (pdata->fullFrame)	//-- process full image
	{
		if (count==0)	//-- EVEN field coming in
		{
			FB_VideoLive(FALSE, ALIGN_NONE);	
			nNextCount=nCount+1;//-- nCount starts with a value -1
								//-- so the first value of nNextCount is 0
   			if (nNextCount>3)
			{
				nNextCount=0;
			}

			//-- set the start of video capture within capture buffer ---
   			CapMemInfo.dwMemOffset=(nNextCount*(DWORD)CapSizeX*CapSizeY*3L)+sizeof(BITMAPINFOHEADER)+1024L;
			FB_VideoCaptureMem(&CapMemInfo, VCM_SETOFFSET);
			FB_VideoLive(TRUE, ALIGN_NONE);
			
			if (nCount>=0)  //---- Don't copy a blank 1st time when nCount = -1
			{
				if (pdata->colTuning &&
					 ( (pdata->timer1_installed && timerCount==10) || !pdata->timer1_installed ) 
					&& ( (pdata->timer2_installed && timerCount==10) || !pdata->timer2_installed) )
				{
					CapMemInfo.dwMemCopyOffset=(nCount*(DWORD)CapSizeX*CapSizeY*3L)+sizeof(BITMAPINFOHEADER)+1024L;
					FB_VideoCaptureMem(&CapMemInfo, VCM_SETCOPYOFFSET);

					CClientDC dc(globaldata.pmainwindow);
					SetStretchBltMode(dc.m_hDC, COLORONCOLOR);

					FB_ScreenToDIB(0, 0, CapSizeX, CapSizeY, (SHORT)STD_OFFSCREEN, (char *)lpDib[nCount]);
					StretchDIBits (dc.m_hDC,
						0, 0, CapSizeX==640?CapSizeX/2:CapSizeX, CapSizeY,
						0, 0, CapSizeX, CapSizeY,//-- From memory
						lpDib[nCount]+sizeof(BITMAPINFOHEADER)
						 + (((LPBITMAPINFOHEADER)lpDib[nCount])->biBitCount == 8 ? 1024 : 0),
						(BITMAPINFO *)lpDib[nCount],
						DIB_RGB_COLORS,
						SRCCOPY);		  
				}

			}	//-- if (nCount>=0)

			nCount=nNextCount;
			//-- update the count of number of full frames
			timerCount++;	//-- increases every two fields ie every frame

		}	//-- if (count==0)	//-- EVEN field coming in

	}	//-- if (pdata->fullFrame)	//-- process full image

	else //-- pdata->fullFrame is FALSE. Seperate Odd Even field processing
	{
		static int gamestartingCount=0;

		if (oddEvenTime==0 || (present-oddEvenTime)>1000)
		{
			GameStarting=TRUE;
			gamestartingCount=0;
		}
		else
		{
			GameStarting=FALSE;
		}

		if (gamestartingCount<8)
		{
			GameStarting=TRUE;
			gamestartingCount++;
		}

		oddEvenTime = present;

		FB_VideoLive(FALSE, ALIGN_NONE);	
		nNextCount=nCount+1;
   		if (nNextCount>3)
		{
			nNextCount=0;
		}

		fieldType[nNextCount]=FB_GetFieldType()==ALIGN_EVEN?0:1;//EVEN==0, ODD==1
		fieldType[nCount]=fieldType[nNextCount]==0?1:0;
		// The previous 1/2 frame (field) must be the opposite way
		// we might have missed 1 or 2 half frames

   		CapMemInfo.dwMemOffset=(nNextCount*(DWORD)CapSizeX*CapSizeY*2*3L)+sizeof(BITMAPINFOHEADER)+1024L;
		FB_VideoCaptureMem(&CapMemInfo, VCM_SETOFFSET);
		FB_VideoLive(TRUE, ALIGN_NONE);
		
	} //-- pdata->fullFrame is FALSE.


	if(((pdata->fullFrame && count==0)||(!pdata->fullFrame && !GameStarting))
		&&(pdata->PositionState != 2 || !pdata->fullFrame))
	{
		if (pdata->FullTrackingOnly)	//-- do full tracking
		{
			//-- find all the robots and ball positions using
			//-- full tracking method
			fullTracking(pdata, FROMGAMEHANDLER);
		}
		else	//-- do incremental tracking
		{
			//-- find all the robots and ball positions using
			//-- incremental tracking method
			copyPointerFromRAM(pdata);
			if (incrementalTracking(pdata))
				fullTracking(pdata, FROMGAMEHANDLER);
		}

		pdata->FrameCount++;	//-- increase the frame count

		//-- Calculate velocities & transfer current positions to
		//-- old positions
		updateVariables(pdata);

		//-- Convert and update strategy variables
		mapall(pdata);
		updateStrategyVariables(pdata);

		if(pdata->diagnostics != OFF)
		{
			//-- post the observer data and display labels for robots and ball
			PostMessage(pdata->pmainwindow->m_hWnd, WM_LBUTTONDBLCLK,NULL,NULL);

			if ( !pdata->start &&
				 gStartingPosition.whosePossession == HOME &&
				 (gStartingPosition.StartPhase == PENALTY ||
				   gStartingPosition.StartPhase == FREEKICK )
			   )
			//-- we have been awarded a penalty shot
			{
				floatPOINT crossingPointS, crossingPoint;
				floatPOINT goaltopS, goaltop, goalbottomS, goalbottom;
				floatPOINT ballPosS;
				float dx, dy;
				floatPOINT robotPosS, robotPos;
				float robotAngle;
				CClientDC dc(pdata->pmainwindow);

				robotPosS = globaldata.robot2posS;
				robotPos = globaldata.robot2pos;
				robotAngle = globaldata.robot2angleS;
				ballPosS = globaldata.ballposS;

				dx = Physical_X - robotPosS.x;
				dy = (float) ( dx*tan( robotAngle*PI/180.0) );

				crossingPointS.x = Physical_X;
				crossingPointS.y = robotPosS.y + dy;
				if (crossingPointS.y > Physical_Y) crossingPointS.y = Physical_Y;
				if (crossingPointS.y < 0) crossingPointS.y = 0;

				//-- map physical coordinates to screen coordinates
				PhysicaltoScreen(&crossingPoint, &crossingPointS, pdata);

				//-- show the point where the ball will cross the goalline
				dc.SetPixel((int)crossingPoint.x, (int)crossingPoint.y, RGB(255, 0, 0) );
				dc.SetPixel((int)crossingPoint.x, (int)crossingPoint.y+1, RGB(255, 0, 0) );
				dc.SetPixel((int)crossingPoint.x, (int)crossingPoint.y-1, RGB(255, 0, 0) );
				dc.SetPixel((int)crossingPoint.x+1, (int)crossingPoint.y, RGB(255, 0, 0) );
				dc.SetPixel((int)crossingPoint.x-1, (int)crossingPoint.y, RGB(255, 0, 0) );

				CPen aWhitePen, *pOldPen;
				aWhitePen.CreatePen(PS_SOLID, 1, RGB(255, 255, 255) );
				pOldPen = (CPen *)dc.SelectObject(&aWhitePen);

				dc.MoveTo((int)robotPos.x, (int)robotPos.y);
				dc.LineTo((int)crossingPoint.x, (int)crossingPoint.y);

				dc.SelectObject(pOldPen);
				aWhitePen.DeleteObject();

				//-- show the top and bottom goal posts
				goaltopS.x = goalbottomS.x = 150.0;	//-- in cms
				goaltopS.y = (float) (85.0 - ROBOTWIDTHby2);
				goalbottomS.y = (float) (45.0 + ROBOTWIDTHby2);
				PhysicaltoScreen(&goaltop, &goaltopS, pdata);
				PhysicaltoScreen(&goalbottom, &goalbottomS, pdata);
				dc.SetPixel((int)goaltop.x, (int)goaltop.y, RGB(255, 255, 255) );
				dc.SetPixel((int)goaltop.x, (int)goaltop.y+1, RGB(255, 255, 255) );
				dc.SetPixel((int)goaltop.x, (int)goaltop.y-1, RGB(255, 255, 255) );
				dc.SetPixel((int)goaltop.x+1, (int)goaltop.y, RGB(255, 255, 255) );
				dc.SetPixel((int)goaltop.x-1, (int)goaltop.y, RGB(255, 255, 255) );

				dc.SetPixel((int)goalbottom.x, (int)goalbottom.y, RGB(255, 255, 255) );
				dc.SetPixel((int)goalbottom.x, (int)goalbottom.y+1, RGB(255, 255, 255) );
				dc.SetPixel((int)goalbottom.x, (int)goalbottom.y-1, RGB(255, 255, 255) );
				dc.SetPixel((int)goalbottom.x+1, (int)goalbottom.y, RGB(255, 255, 255) );
				dc.SetPixel((int)goalbottom.x-1, (int)goalbottom.y, RGB(255, 255, 255) );

				dx = crossingPointS.x - ballPosS.x;
				dy = crossingPointS.y - ballPosS.y;
				gstartPhaseVal[PENALTY].kickdistance = (float) sqrt(dx*dx + dy*dy)
														+ (float)ROBOTWIDTHby2;

			}//-- we have been awarded a penalty shot
			else
			if (gStartingPosition.whosePossession == OPPONENT &&
				gStartingPosition.StartPhase == PENALTY)
			//-- opponent team has been awarded a penalty shot against us
			{
				floatPOINT clickPoint;
				floatPOINT goaltopS, goaltop, goalbottomS, goalbottom;
				CClientDC dc(pdata->pmainwindow);

				clickPoint.x = (float)globaldata.homegoaltop.x;
				clickPoint.y = (float)globaldata.capPoint.y;

				//-- show the clicked point where the goalie should go to
				dc.SetPixel((int)clickPoint.x, (int)clickPoint.y, RGB(255, 0, 0) );
				dc.SetPixel((int)clickPoint.x, (int)clickPoint.y+1, RGB(255, 0, 0) );
				dc.SetPixel((int)clickPoint.x, (int)clickPoint.y-1, RGB(255, 0, 0) );
				dc.SetPixel((int)clickPoint.x+1, (int)clickPoint.y, RGB(255, 0, 0) );
				dc.SetPixel((int)clickPoint.x-1, (int)clickPoint.y, RGB(255, 0, 0) );

				//-- show the top and bottom goal posts
				goaltopS.x = goalbottomS.x = 0;	//-- in cms
				goaltopS.y = 85.0;
				goalbottomS.y = 45;
				PhysicaltoScreen(&goaltop, &goaltopS, pdata);
				PhysicaltoScreen(&goalbottom, &goalbottomS, pdata);
				dc.SetPixel((int)goaltop.x, (int)goaltop.y, RGB(255, 255, 255) );
				dc.SetPixel((int)goaltop.x, (int)goaltop.y+1, RGB(255, 255, 255) );
				dc.SetPixel((int)goaltop.x, (int)goaltop.y-1, RGB(255, 255, 255) );
				dc.SetPixel((int)goaltop.x+1, (int)goaltop.y, RGB(255, 255, 255) );
				dc.SetPixel((int)goaltop.x-1, (int)goaltop.y, RGB(255, 255, 255) );

				dc.SetPixel((int)goalbottom.x, (int)goalbottom.y, RGB(255, 255, 255) );
				dc.SetPixel((int)goalbottom.x, (int)goalbottom.y+1, RGB(255, 255, 255) );
				dc.SetPixel((int)goalbottom.x, (int)goalbottom.y-1, RGB(255, 255, 255) );
				dc.SetPixel((int)goalbottom.x+1, (int)goalbottom.y, RGB(255, 255, 255) );
				dc.SetPixel((int)goalbottom.x-1, (int)goalbottom.y, RGB(255, 255, 255) );

			}//-- opponent team has been awarded a penalty shot against us

			if (pdata->DisplayBoundaries)
				displayBoundaries();

		}	//-- if(pdata->diagnostics != OFF)

		if (pdata->diagnostics == LOW)
		{
			//-- post position and angle data every 100 frames
			pdata->update=TRUE;
			if ( (pdata->FrameCount % 100) == 0)
				PostMessage(pdata->pmainwindow->m_hWnd, WM_RBUTTONDBLCLK,NULL,NULL);
		}
		else
		if(pdata->diagnostics == HIGH)
		{
			//-- post position and angle data every frame
			pdata->update=TRUE;
			PostMessage(pdata->pmainwindow->m_hWnd, WM_RBUTTONDBLCLK,NULL,NULL);
		}

		//-- Implement Strategy
		if (pdata->start==TRUE)
		{
			pdata->GVelSet = FALSE;
			pdata->R1VelSet = FALSE;
			pdata->R2VelSet = FALSE;

			//-- call the function which selects the action
			myStrategy();

			//-- Striker and defender must avoid pushing the goalie
			if (!gRemoved.Robot1)
			{
				avoidGoalie(HROBOT1);
				turnAtWalls(HROBOT1);
			}
			if (!gRemoved.Robot2)
			{
				avoidGoalie(HROBOT2);
				turnAtWalls(HROBOT2);
			}

			//-- separate the two robots if they are stuck
			if ( !(gRemoved.Robot1 || gRemoved.Robot2) )
			{
				separateRobots();
			}

			if (!gRemoved.Goalie && pdata->GVelSet == FALSE)
			{
				velocity(HGOALIE, 0, 0);
			}
			if (!gRemoved.Robot1 && pdata->R1VelSet == FALSE)
			{
				velocity(HROBOT1, 0, 0);
			}
			if (!gRemoved.Robot2 && pdata->R2VelSet == FALSE)
			{
				velocity(HROBOT2, 0, 0);
			}

		}	
		else //-- pdata->start==FALSE
		{
			if(pdata->PositionState != 2)	//-- robots have not reached stable/final position
				placeRobots();
		}

		SendPacket();

		//-- The following line makes the game run just one round
		//pdata->start = FALSE;

		//-- calculate time difference -------------------
		present = timeGetTime();
		pdata->timeDiff = present - past;

	}	//-- if ......( pdata->start==TRUE  || pdata->PositionState != 2)

	if (!pdata->fullFrame)
		nCount=nNextCount;

	count++;	//-- count increases by 1 for every VSYNC
				//-- count is 0 for EVEN field, 1 for ODD field
	count%=2;	//-- count toggles between 0 and 1
	if (FBUSINSTALLED) FB_ClearIRQ(INTTYPE, wIRQNum);	//-- clear pending interrupt

	return;
}	//-- gameHandler()
